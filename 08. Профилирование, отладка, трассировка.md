 План занятия:
 - Профилирование
 - Профилирование тестов
 - Профилирование приложения
 - Отладка
 - Delve
 - Трассировка

> Чем крут Go? Помимо прочего, тем, что весь необходимый разработчику инструментарий присутствует из коробки. И не нужно спорить, чем пользоваться.

___
<h5>Профилирование</h5>
**Профилирование — это снятие профиля**.
Профиль — это данные многократных замеров потребления ресурсов во время выполнения программы.

Профилирование предназначено для изучения потребления ресурсов отдельными частями (функциями) приложения с целью оптимизации производительности.

Можно снимать профиль во время выполнения тестов. Однако это имеет смысл только для бенчмарков.

Можно профилировать работу всего приложения (это для нас наиболее интересно). Go предоставляет средства визуализации профиля в формате pdf, svg или веб-документа.
___
<h5>Профилирование бенчмарков</h5>
Можно записать профиль выполнения тестов, используя команды:
- `go test -run xxx -bench . -cpuprofile cpu.out` 
	- Здесь `xxx` - для запуска несуществующего теста. С помощью `-cpuprofile` мы можем указать, куда необходимо сохранить профиль потребления ресурсов.
- `go test -run xxx -bench . -memprofile mem.out`
	- С помощью `-memprofile` мы можем указать, куда сохранить профиль потребления памяти.

После, полученный профиль можно перевести в pdf, svg или отобразить в браузере:
**svg**:
	`go tool pprof -svg cpu.out > cpy.svg`
**pdf**:
	`go tool pprof -df cpu.out > cpu.pdf`
**браузер**:
	`go tool pprof -web cpu.out`
	`go tool pprof -web mem.out`
___
<h5>Профилирование приложения</h5>
Наше приложение работает постоянно (например, веб-сервер), и оно потребляет ресурсы неожиданным для нас образом. Поэтому мы должны иметь возможность профилировать его в любой момент времени — под нагрузкой, при нормальной работе пользователей и т.д. Для этого нам необходим http-сервер.

Чтобы снять профиль приложения нужно подключить пакет "net/http/pprof", используя безымянный импорт:
`import _ "net/http/pprof"`

Такой импорт регистрирует http-обработчики для сбора различных метрик. 

После этого нужно запустить http-сервер, который будет обрабатывать запросы на получение различных профилей (по процессору, памяти, блокировкам и т.д.)

> [!NOTE] Про безымянный импорт и init
> Когда мы совершаем безымянный импорт, в пакете вызывается функция `init`.
> В пакете "net/http/pprof" функция `init` отвечает за регистрацию эндпоинтов для обработки метрик в целях профилирования.

Список профилей доступен по адресу: http://localhost/debug/pprof

Визуализацию профилей можно посмотреть так же, как и для бенчмарков, но указав ссылку вместо файла:
	`go tool pprof -web http://localhost/debug/pprof/profile`
	`go tool pprof -web http://localhost/debug/pprof/heap`
(заменить localhost на адрес приложения)

Чем больше и краснее прямоугольник на визуализации, тем больше работы в нём происходит. Чем жирнее стрелка, тем больше работы происходит по пути.

Документация: https://github.com/google/pprof/blob/master/doc/README.md

Информацию о памяти можно снимать практически бесплатно, в то время как снятие профиля процессора — довольно затратная операция.
___
<h5>Отладка</h5>
Отладка — это поиск и исправление ошибок в уже написанном коде, когда он работает не так, как мы ожидаем.

В отличие от тестов, отладка применяется ко всему приложению, а не к его частям.

Типовые причины применения отладки: приложение исправно работает на тестовых примерах, но неверно работает с реальными данными.

Отладка не предназначена для выявления проблем с производительностью. Она используется для выявления проблем в логике работы приложения.

Для отладки приложения используется специальный инструмент — отладчик (дебаггер), специальный софт, который подключается к программе и заглянуть в неё изнутри — приостановить работу программы на любой строчке кода (точки останова), изучить значения переменных, модифицировать их и т.д.

Отладчик следует рассматривать как крайнее средство, когда анализ кода не позволяет выявить ошибку (считается, что проблемы кода необходимо искать глазами). Но, блин, что за мезозой?! Если у меня есть удобный инструмент, почему бы мне не использовать его, вместо того, чтобы трайхардить. В общем, мнения бытуют разные.
___
<h5>Delve</h5>
Delve это отладчик для Go: https://github.com/go-delve/delve. Delve не является частью установки Go, однако IDE знают о нём и устанавливают автоматически. 

Delve имеет интерфейс командной строки.

Команда `dlv debug` в каталоге с пакетом "main" компилирует пакет, запускает и подключает  к нему отладчик. CLI-режим не очень удобен, поэтому IDE предоставляют графический интерфейс для Delve.
___
<h5>Продвинутая техника дебага</h5>
**Глобальные объекты**. По умолчанию, дебаггер не показывает глобальные объекты, поэтому их необходимо добавить в раздел "watch".

**Изменение значений переменных в рантайме**. Да, можно. Полезно для моделирования какой-либо конкретной ситуации.

**Отладка в горутине**. Мы не попадаем в горутину, как же выполнить отладку внутри неё? Чтобы отлаживать горутину, мы должны поставить точку остановка прямо в ней. Мы не сможем попасть в горутину, нажав на кнопку "войти в функцию" при дебаге.

**Условная точка останова**. Попадание в эту точку останова происходит только когда выполняется указанное условие.
___
<h5>Трассировка</h5>
<h6>Отсебятина</h6>
Под трассировкой обычно понимают отслеживание пути запроса через нашу большую систему.

Обычно, у нас есть микросервисная система, состоящая из большого количества сетевых приложений, которые взаимодействуют друг с другом. Например, приходит запрос от пользователя. Запрос проходит через несколько сервисов.

Если с этим вопросом возникла проблема, мы хотим понять, на каком этапе (в каком сервисе, функции) она произошла. Для этого нам необходимо уметь отследить путь каждого конкретного запроса.

Обычно, для этих целей, каждый запрос снабжается уникальным UUID-идентификатором перед тем, как запрос пойдёт по всем остальным системам. 
В свою очередь, сервисы пишут информацию о приходящих запросах в журналы. 
В результате становится возможным отследить путь запроса от начала и до конца.
<h6>От лектора</h6>
Трассировка — отслеживание событий во время выполнения:
- Выполнение вычислений на конкретных ядрах;
- Работа сборщика мусора;
- Переключение между потоками;

Трассировка позволяет наглядно увидеть загрузку ядер процессора во время работы программы, а также **ситуации давления на сборщик мусора**.
Статья про сборщик мусора: https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html

Для включения низкоуровневой Go-шной трассировки используется функция `trace.Start()` пакета "runtime/trace". Функция `trace.Start()` пишет журнал трассировки в предоставленный `io.Writer`. Для просмотра трассировки используется команда `go tool trace "файл трассировки"`.

Однако, для рабочей системы это не очень применимо (лишние инструкции `trace`, которые как бы ни к чему). Этот метод подходит для локальной трассировки, к которой разработчик заранее подготовился.

```go
f, err := os.Create("trace.out")
if err != nil {
	log.Fatal(err)
}
trace.Start(f)
defer f.Close()
defer trace.Stop()
...
```

