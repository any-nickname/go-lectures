План занятия:
- Сетевое программирование
- Программирование на транспортном уровне
- Пакет "net"
- Тестирование сетевой службы
___
<h5>Сетевое программирование</h5>
Литература: "Network Programming with Go", Jan Newmarch
<h6>Abstract</h6>
Сети и их организация не меняются десятилетиями. Сетевое взаимодействие по большей части унифицировано, хотя существует множество стандартов и протоколов.

Почти все современные информационные системы подразумевают взаимодействие по сети. Как между пользователями и системой, так и между частями системы.
Go создавался для разработки крупных, а, следовательно, и распределённых сетевых приложений.
Даже если приложение не является распределённым, скорее всего оно предоставляет информацию по сети своим пользователям.
<h6>Уровни протоколов</h6>
Взаимодействие по сети происходит в соответствии с некоторой иерархической моделью, состоящей из уровней. Отправляемая и получаемая нами информация проходит по уровням этой модели, трансформируясь в формат, удобный для физической передачи (по кабелю).

Таким образом, информация на передающем устройстве проходит трансформацию (упаковку, кодирование) по уровням сверху вниз. На принимающем узле происходит обратная трансформация — информация декодируется в соответствии с той же моделью, снизу вверх.

Каждому уровню модели соответствуют свои протоколы. Конкретная реализация модели использует один или несколько протоколов на каждом уровне.

Протокол — это формальное соглашение о формате и других характеристиках процесса сетевого взаимодействия.

Наиболее известными являются модель OSI (open systems interconnection теоретическая) и модель TCP/IP (практическая).
<h6>Модель OSI</h6>
https://ru.wikipedia.org/wiki/Сетевая_модель_OSI
Модель OSI является эталонной теоретической моделью и на практике в полном объёме не реализуется.

| Модель OSI            | Функции                                                  | Протоколы                                               |
| --------------------- | -------------------------------------------------------- | ------------------------------------------------------- |
| Уровень приложений    | Доступ к сетевым службам                                 | HTTP, FTP, SMTP                                         |
| Уровень представления | Представление и шифрование данных                        | ASCII, EBCDIC, JPEG                                     |
| Сеансовый уровень     | Управление сеансом связи                                 | RPC, RAP                                                |
| Транспортный уровень  | Прямая связь между конечными пунктами и надёжность       | TCP, UDP, SCTP                                          |
| Сетевой уровень       | Определение маршрута и логическая адресация              | IPv4, IPv6, IPsec, AppleTalk                            |
| Канальный уровень     | Управление доступом к среде. Физическая адресация        | PPP, IEEE, 802.2, Ethernet, DSL, L2TP, ARP              |
| Физический уровень    | Работа со средой передачи, сигналами и двоичными данными | USB, витая пара, коаксиальный кабель, оптический кабель |

Сети по своей организации и логике работы довольно сильно похожи на обыкновенную почту :)
Мы заказываем баночку с вареньем:
1. Отправитель берёт баночку с вареньем, заворачивает её в пакетик;
2. Приезжает курьер, упаковывает пакетик в стандартную коробку;
3. Курьер отвозит коробку на почту, на почте её оборачивают пупырчатой плёнкой, обогащают информацией об адресе получателя, и передают для физической транспортировки;
4. Когда посылка приезжает в конечное отделение почты, запускается обратный процесс.
<h6>Модель TCP/IP</h6>
https://ru.wikipedia.org/wiki/TCP/IP
На практике, чаще используется модель TCP/IP, содержащая 4 уровня. В этой модели:
- уровень представления и приложений объединены в уровень приложений
- транспортный и сеансовый уровни из OSI объединены в транспортный уровень
- сетевой уровень из OSI остался сетевым
- физический и канальный уровни из OSI объединены в уровень сетевого доступа


| Стек протоколов TCP/IP   | Функции                                                                       | Протоколы                                                                                                                          |
| ------------------------ | ----------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| Уровень приложений       | Работа большинства сетевых приложений                                         | HTTP, RTSP, FTP, DNS                                                                                                               |
| Транспортный уровень     | Прямая связь между конечными пунктами и надёжность                            | TCP, UDP, SCTP, DCCP                                                                                                               |
| Межсетевой уровень       | Определение маршрута и логическая адресация                                   | IPv4, IPv6, ICMPv4, ICMPv6                                                                                                         |
| Уровень сетевого доступа | Физическая адресация. Работа со средой передачи, сигналами, двоичными данными | Ethernet, IEEE 802.11, Wireless Ethernet, SLIP, Token Ring, ATM и MPLS, физическая среда и принципы кодирования информации, T1, E1 |

Для нас, как разработчиков, имеет значение только транспортный уровень и уровень приложений, поскольку мы не работаем на других уровнях (в рамках прикладного программирования), хотя точно стоит иметь знания о том, как работают и остальные уровни.

Транспортный уровень отвечает за передачу данных и работает по протоколам TCP, UDP.
Протокол уровня приложений является специфическим для каждого типа приложений, поэтому работа на уровне приложений отличается для каждого конкретного приложения.

Go предоставляет готовые инструменты для сетевого взаимодействия приложений по протоколам TCP и UDP на уровне транспорта, и HTTP и RPC на уровне приложений.

Сторонние пакеты добавляют поддержку большинства популярных протоколов.

Сегодня будет речь идти именно о транспортном уровне.
<h6>Типы сетевого взаимодействия</h6>
Характер сетевого взаимодействия может быть различным.
Выделяют следующие категории:
- По способу взаимодействия: обмен сообщениями или удалённый вызов процедур (RPC)
- По типу соединений: синхронное, асинхронное, потоковое соединение и взаимодействие типа pub/sub

Информационная система, части которой взаимодействуют по сети, называют распределённой.

<h5>Программирование на транспортном уровне</h5>
Программирование на транспортном уровне подразумевает работу с протоколами TCP и UDP.
При этом обычно на сетевом уровне используется протокол IP. Адрес службы в сети на сетевом уровне определяется IP-адресом, а на транспортном — номером TCP/UDP порта.

Таким образом полный адрес службы имеет вид `ip:port` (комбинация IP и порта клиента и IP и порта сервера называется **сокетом**), например: `192.168.0.20:5544`.

Порты до 1024 считаются зарезервированными: https://ru.wikipedia.org/wiki/Список_портов_TCP_и_UDP
Также важно понимать, на каком IP-адресе будет работать сетевая служба; универсальным решением является 0.0.0.0 (это означает "слушать на всех сетевых интерфейсах").

Таким образом, IP-адрес характеризует компьютер в системе (т.е. целую систему), а порт — конкретную сетевую службу (приложение), запущенную на этом компьютере и зарегистрированную на этом компьютере.

**TCP:**
- устанавливает и поддерживает соединение между клиентом и сервером
- используется потоковая передача (нет концепции сообщений)
- гарантируется доставка пакетов с данными (целостность и порядок)
Устанавливается два канала, от клиента к серверу и от сервера к клиенту.

**UDP:**
- не используются соединения
- нет гарантии доставки пакетов

UDP быстрее, чем TCP, однако он не гарантирует доставку. Поэтому, UDP стоит использовать там, где скорость приоритетнее надёжности (например, видео-звонки).
___
<h5>Пакет "net"</h5>
https://pkg.go.dev/net
Пакет "net" предоставляет инструменты для создания сетевых клиентов и серверов, включая взаимодействие по протоколам IP/TCP/UDP, разрешение имён по протоколу DNS, использование сокетов ОС.

Основные инструменты пакета:
- Функция `Dial()` для подключения к сетевой службе,
- Функции `Listen()` и `Accept()` для регистрации сетевой службы и приёма подключений,
- Интерфейс `Listener` для управления соединением (приём, закрытие),
- Интерфейс `Conn` для чтения и записи сообщений посредством соединения.

Тип `net.Conn` является интерфейсом, который абстрагирует сетевое подключение и позволяет обмениваться сообщениями между клиентом и сервером, а также устанавливать параметры подключения.
Этот интерфейс содержит методы:
```go
Read (b []byte) (n int, err error)
Write(b []byte) (n int, err error)
Close() error
LocalAddr() Addr
RemoteAddr() Addr
SetDeadline(t time.Time) error
SetReadDeadline(t time.Time) error
SetWriteDeadline(t time.Time) error
```

Приведём пример сервера и клиента простой сетевой службы, которая возвращаем текущее время в соответствии с https://tools.ietf.org/html/rfc867.
Сервер регистрирует сетевую службу с помощью `net.Listen()` и запускает бесконечный цикл обработки входящих подключений. Клиент подключается с помощью `net.Dial()`.
Для проверки работоспособности сетевых служб можно использовать утилиту `telnet`.

Сервер:
```go
package main  
  
import (  
    "log"  
    "net"    
    "time"
)  
  
func handler(conn net.Conn) {  
    daytime := time.Now().Format(time.RubyDate)  
    _, err := conn.Write([]byte(daytime))  
    if err != nil {  
       log.Fatal(err)  
    }  
    err = conn.Close()  
    if err != nil {  
       log.Fatal(err)  
    }  
}  
  
func main() {  
    // Регистрация сетевой службы на всех сетевых интерфейсах на порту 13  
    listener, err := net.Listen("tcp4", ":13")  
    if err != nil {  
       log.Fatal(err)  
    }  
  
    // Цикл обработки клиентских подключений  
    for {  
       conn, err := listener.Accept()  
       if err != nil {  
          log.Fatal(err)  
       }  
  
       handler(conn)  
    }  
}
```

Клиент:
```go
package main  
  
import (  
    "fmt"  
    "io"    
    "log"    
    "net"
)  
  
func main() {  
    conn, err := net.Dial("tcp4", "localhost:13")  
    if err != nil {  
       log.Fatal(err)  
    }  
  
    msg, err := io.ReadAll(conn)  
    if err != nil {  
       log.Fatal(err)  
    }  
  
    fmt.Println("Ответ от сервера:", string(msg))  
}
```

<h6>Ещё один пример сетевой службы</h6>
Напишем эхо-сервер, который будет возвращать клиенту то, что клиент ввёл с клавиатуры.

```go
package main  
  
import (  
    "bufio"  
    "fmt"    
    "log"    
    "net"
)  
  
func handler(conn net.Conn) {  
    defer func() {  
       if err := conn.Close(); err != nil {  
          log.Fatal(err)  
       }  
    }()  
    defer fmt.Println("Connection closed")  
  
    r := bufio.NewReader(conn)  
    for {  
       msg, _, err := r.ReadLine()  
       if err != nil {  
          log.Println(err)  
          return  
       }  
  
       msg = append(msg, '\n')  
  
       _, err = conn.Write(msg)  
       if err != nil {  
          log.Println(err)  
          return  
       }  
    }  
}  
  
func main() {  
    // Регистрация сетевой службы на порту 12345.  
    listener, err := net.Listen("tcp4", ":12345")  
    if err != nil {  
       log.Fatal(err)  
    }  
    // Завершение работы сетевой службы.  
    defer func() {  
       if err = listener.Close(); err != nil {  
          log.Fatal(err)  
       }  
    }()  
  
    fmt.Println("Server listens port 12345")  
  
    // Цикл обработки клиентских подключений.  
    for {  
       conn, err := listener.Accept()  
       if err != nil {  
          log.Fatal(err)  
       }  
       go handler(conn)  
    }  
}
```

Но чтобы сделать сервер из примера выше ближе к состоянию "production-ready", стоит добавить штучку — тайм-ауты ദ്ദി(˵ •̀ ᴗ - ˵ ) 
Может случиться так, что клиент висит и бездействует — в этом случае лучше закрыть соединение по истечении некого тайм-аута, иначе соединение может висеть вечно и потреблять ресурсы сервера.

Протокол TCP оперирует **потоком байт**, у него нет такого понятия как "сообщение". Если мы сами не знаем, что такое "сообщение" с точки зрения нашего приложения, то это печально ( • ᴖ • ｡)
TCP нам не подскажет, что клиент закончил сообщение, а почему в потоке нет байт — неизвестно.
Мы всегда должны понимать, каким образом поделить поток байт на сообщение. 
В нашем примере, символ новой строки '\\n' используется как конец каждого сообщения.

> [!NOTE] Два важных слов
> 1. При работе с TCP для чтения потока байт от клиента **необходимо использовать буфер**.
> 2. Мы **должны понимать протокол приложения**, чтобы понимать, как делить поток байт на сообщения.

<h6>Deadline</h6>
Важно не забывать про такой аспект сетевой службы как тайм-аут подключения.
По умолчанию, TCP-тайм-аут отключен.

Может случиться так, что клиент висит бездействует — в этом случае лучше закрыть соединение по истечении некого тайм-аута, иначе соединение может висеть вечно и потреблять ресурсы сервера.

Добавим тайм-аут в предыдущий пример:
```go
package main  
  
import (  
    "bufio"  
    "fmt"    
    "log"    
    "net"    
    "time"
)  
  
func handler(conn net.Conn) {  
    defer func() {  
       if err := conn.Close(); err != nil {  
          log.Fatal(err)  
       }  
    }()  
    defer fmt.Println("Connection closed")  
  
    err := conn.SetDeadline(time.Now().Add(time.Second * 5))  
    if err != nil {  
       log.Println(err)  
       return  
    }  
  
    r := bufio.NewReader(conn)  
    for {  
       msg, _, err := r.ReadLine()  
       if err != nil {  
          log.Println(err)  
          return  
       }  
  
       msg = append(msg, '\n')  
  
       _, err = conn.Write(msg)  
       if err != nil {  
          log.Println(err)  
          return  
       }  
  
       err = conn.SetDeadline(time.Now().Add(time.Second * 5))  
       if err != nil {  
          log.Println(err)  
          return  
       }  
    }  
}  
  
func main() {  
    // Регистрация сетевой службы на порту 12345.  
    listener, err := net.Listen("tcp4", ":12345")  
    if err != nil {  
       log.Fatal(err)  
    }  
    // Завершение работы сетевой службы.  
    defer func() {  
       if err = listener.Close(); err != nil {  
          log.Fatal(err)  
       }  
    }()  
  
    fmt.Println("Server listens port 12345")  
  
    // Цикл обработки клиентских подключений.  
    for {  
       conn, err := listener.Accept()  
       if err != nil {  
          log.Fatal(err)  
       }  
       go handler(conn)  
    }  
}
```

___
<h5>Тестирование сетевой службы</h5>
Для тестирования TCP/UDP службы следует использовать `net.Pipe()` — эта функция создаёт и возвращает двустороннее соединение, оба конца которого реализуют интерфейс `net.Conn`.

client <----------> server

Эта функция привлекательна для использования, потому что мы, зачастую, говорим о модульных (юнит) тестах, для которых не всегда будет возможно поднять настоящий сервер для тестирования (например, у нас может не быть права занимать какой-либо порт).

Техника тестирования заключается в запуске отдельного потока для чтения результата работы обработчика соединения.
Запись осуществляется в основном потоке.
Или наоборот.

`timeserver.go:`
```go
package main  
  
import (  
    "bufio"  
    "log"    
    "net"    
    "strings"    
    "time"
)  
  
// Сетевой адрес.  
const addr = "0.0.0.0:12345"  
  
// Протокол сетевой службы.  
const proto = "tcp4"  
  
func main() {  
    listener, err := net.Listen(proto, addr)  
    if err != nil {  
       log.Fatal(err)  
    }  
    defer func() {  
       if err := listener.Close(); err != nil {  
          log.Fatal(err)  
       }  
    }()  
  
    for {  
       conn, err := listener.Accept()  
       if err != nil {  
          log.Fatal(err)  
       }  
       go handleConn(conn)  
    }  
}  
  
func handleConn(conn net.Conn) {  
    reader := bufio.NewReader(conn)  
    b, err := reader.ReadBytes('\n')  
    if err != nil {  
       log.Println(err)  
       return  
    }  
  
    msg := strings.TrimSuffix(string(b), "\n")  
    msg = strings.TrimSuffix(msg, "\r")  
  
    if msg == "time" {  
       _, err = conn.Write([]byte(time.Now().String() + "\n"))  
       if err != nil {  
          log.Println(err)  
          return  
       }  
    }  
  
    err = conn.Close()  
    if err != nil {  
       log.Println(err)  
    }  
}
```

`timeserver_test.go:`
```go
package main  
  
import (  
    "bufio"  
    "log"    
    "net"    
    "sync"   
    "testing"
)  
  
func Test_handleConn(t *testing.T) {  
    // Имитация полнодуплексного  
    // сетевого соединения.    
    srv, cl := net.Pipe()  
  
    // Мы должны дождаться завершения всех потоков.  
    var wg sync.WaitGroup  
    wg.Add(1)  
  
    // Обработчик подключения запускается  
    // в отдельном потоке.    
    go func() {  
       handleConn(srv)  
       if err := srv.Close(); err != nil {  
          log.Println(err)  
       }  
       wg.Done()  
    }()  
  
    // В основном потоке теста,  
    // клиент отправляет сообщение в трубу.    
    // Эти сообщения сервер прочтёт в отдельной горутине.   
    _, err := cl.Write([]byte("time\n"))  
    if err != nil {  
       log.Println(err)  
    }  
  
    // Чтение ответа от сервера.  
    reader := bufio.NewReader(cl)  
    b, err := reader.ReadBytes('\n')  
    if err != nil {  
       log.Println(err)  
    }  
  
    // Проверка ответа  
    if len(b) < 10 {  
       t.Error("Время не получено")  
    }  
  
    wg.Wait()  
    err = cl.Close()  
    if err != nil {  
       log.Println(err)  
    }  
}
```