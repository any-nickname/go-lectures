Go позволяет легко писать программы, использующие современные многоядерные процессоры с большим количеством потоков.

План занятия:
- Конкурентное программирование и параллелизм
- Инструменты конкурентного программирования
- Синхронизация потоков
- Общая память и условие гонки
- Типовые ошибки
- Пакет "sync/atomic"
- Шаблоны проектирования
- Контекст

Конкурентное программирование != параллельное программирование.
___
<h5>Конкурентное программирование и параллелизм</h5>
Конкурентное программирование != параллельное программирование.

Литература:
- "Effective Concurrency in Go", Burak Serdar

Конкурентное программирование — это модель организации кода, представляющая программу в виде набора независимых потоков исполнения, возможно, взаимодействующих друг с другом.


> [!NOTE] Конкурентность != параллелизм
> Отличие конкурентности от параллелизма в том, что конкурентность — это свойство нашего кода, тогда как параллелизм — свойство системы. 
> 
> Мы можем описать однопоточную программу, в цикле вычисляющую сто корней чисел, и компилятор может оптимизировать её таким образом, чтобы независящие друг от друга итерации выполнялись параллельно на разных ядрах. То есть наша программа может стать параллельной даже без нашего участия, с помощью оптимизаций компилятора.
> 
> В свою очередь, конкурентный код мы пишем целенаправленно и сознательно.

В своей основе Go полагается на модель "Взаимодействующих последовательных процессов" (CSP). Эта модель предполагает коммуникацию между процессами посредством каналов.

Таким образом, конкурентное программирование в Go — это способ организации программы в виде набора независимых процессов, обменивающихся информацией с помощью каналов.

**Don't communicate by sharing memory, share memory by communicating.** (Go Proverbs)

Почему код конкурентный? Потому что он конкурирует за ресурсы системы (процессор, память), на которой выполняется.
___
<h5>Инструменты конкурентного программирования</h5>
<h6>goroutines</h6>
Горутина (goroutine, поток) — независимый поток выполнения.

Поток похож на процесс или поток ОС, но не является им.
Отличие горутин от потоков ОС:
https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html
(отличие горутин от потоков ОС и принцип их работы — типовой вопрос на собеседовании)

Любая Go-программа содержит как минимум один поток: `main()`.

Любая функция может быть запущена в отдельном потоке, если перед её вызовом добавить ключевое слово `go`.

Важно помнить:
- Горутины не могут возвращать значений (программа ушла вперёд);
- Всегда нужно чётко понимать, каким образом завершится выполнение потока;
- Горутины — ресурсы, которые нужно контролировать.

С каждой программой связана как минимум одна горутина —функция main — и с её завершением завершается вся программа.

Если какие-то горутины не успели завершить работу до завершения функции main, они будут принудительно остановлены.
<h6>channels</h6>
Каналы — это механизм коммуникации потоков. Каналы можно представлять как трубы (по которым курсируют данные), и они служат для передачи данных между горутинами, способствуя их синхронизации.

Каналы бывают:
- буферизованные
- небуферизованные

Каналы имеют ссылочный тип `chan`, для объявления используется такой синтаксис:
`var myChannel chan int`, после ключевого слова `chan` указывается тип данных, который может курсировать по каналу.

Для определения канала используется ключевое слово `make`:
`myChannel = make(chan int)`

Для каналов используется оператор работы с каналом `<-`.
Если он указан перед именем канала, то осуществляется чтение из канала. Если после имени канала — осуществляется запись в канал.
**Чтение из канала и запись в него — это блокирующие операции.** Если мы что-то пишем в канал, то на этом месте возникнет блок до того момента, пока кто-то из этого канала данные не прочитает. Таким образом, нет смысла использовать канал в одном потоке. Если у нас дополнительных горутин, то мы не сможем использовать канал, потому что любая операция с ним (чтение/запись) заблокирует программу.

Каналы работают по принципу очереди, FIFO.
<h6>способы чтения из канала</h6>
Из канала можно читать двумя способами:
- оператор `range`: читает до тех пор, пока канал не будет закрыт
- оператор `<-`, возвращающий два значения: `val, ok := <- ch`, `ok` равен true если канал открыт. Если указан только `val` без `ok`, то будет возвращено только значение.
\
Программа блокируется:
- При записи в канал, если достигнут предел ёмкости канала
- При чтении из канала

Канал может быть закрыт встроенной функцией `close(ch)`, чтение из закрытого канала не блокирует программу и всегда возвращает значение по умолчанию для типа данных канала (если у канала нет непрочитанного буфера).

**Попытка записи в закрытый канал вызывает панику.**

Канал — это ресурс. Важно явно закрывать канал.
<h6>буферизованный канал</h6>
Буферизованные каналы применяются чаще, чем небуферизованные, так как, как правило, не ясно, какой длины необходимо выделять этот буфер.
___
<h5>Оператор select</h5>
Если у нас имеется несколько каналов, мы можем осуществлять их чтение с помощью оператора `select`:
```go
OUT:
	for {
		select {
		case val, ok := <-ch1:
			if !ok {
				break OUT
			}
			fmt.Println(val)
		case val := <-ch2:
			fmt.Println(val)
		default:
		}
	}
}
```

`select` выбирает для чтения случайный непустой канал.
___
<h5>Синхронизация горутин</h5>
Для синхронизации работы горутин используются два механизма:
- каналы
- группа ожидания (sync.WaitGroup)

Группа ожидания предназначена для ожидания завершения работы нескольких горутин. По сути, WaitGroup это счётчик, безопасный для обращения из разных потоков. WaitGroup реализует примитив синхронизации — семафор.
```go
package main  
  
import (  
    "fmt"  
    "sync")  
  
func printNum(a int, wg *sync.WaitGroup) {  
    fmt.Println(a)  
    wg.Done()  
}  
  
func main() {  
    const N = 10  
  
    var wg sync.WaitGroup  
    wg.Add(N)  
  
    for i := 0; i < N; i++ {  
       go printNum(i, &wg)  
    }  
  
    wg.Wait()  
}
```

Каналы предназначены для коммуникаций и управления последовательностью выполнения горутин.
```go
package main  
  
import "fmt"  
  
func step1(ch chan<- string) {
	fmt.Println("step 1 worked")
    close(ch)
}  
  
func step2(ch <-chan string) {
	<-ch
    fmt.Println("step 2 worked")
}  
  
func main() {  
    ch := make(chan string)  
    go step1(ch)  
    step2(ch)  
}
```

При использовании каналов, между горутинами может передаваться информация, однако каналы могут использоваться и только для синхронизации работы, при этом вместо записи в канал используют только операцию закрытия канала.
___
<h5>Общая память и условие гонки</h5>
Альтернативой механизму каналов для обмена информацией между горутинами является общая память: разделяемые несколькими потоками переменные.

**Важнейшее:**
При использовании общей памяти, важно обеспечивать последовательный доступ к разделяемой памяти из разных горутин (т.е. не допускать даже гипотетически одновременного чтения и записи из разных потоков). Иначе результат будет непредсказуемым.

Если доступ к общей памяти требуется только на чтение, то этой проблемы не существует.

Отличная статья: https://golang.org/ref/mem

_
Пример плохого кода, в котором не озаботились последовательным доступом разных горутин к общей памяти:
```go
package main  
  
import (  
    "fmt"  
    "sync")  
  
var counter int  
  
func inc(wg *sync.WaitGroup) {  
    defer wg.Done()  
    for i := 0; i < 10_000; i++ {  
       counter++  
    }  
}  
  
func main() {  
    var wg sync.WaitGroup  
    wg.Add(2)  
  
    go inc(&wg)  
    go inc(&wg)  
  
    wg.Wait()  
  
    fmt.Println(counter)  
}
```

Результат работы этого кода каждый раз разный, хотя, казалось бы, он всегда должен выводить число 20.000 на экран.

Корректный код:
```go
package main  
  
import (  
    "fmt"  
    "sync")  
  
var mu sync.Mutex  
var counter int  
  
func inc(wg *sync.WaitGroup) {  
    mu.Lock()  
    defer mu.Unlock()  
    defer wg.Done()  
    for i := 0; i < 10_000; i++ {  
       counter++  
    }  
}  
  
func main() {  
    var wg sync.WaitGroup  
    wg.Add(2)  
  
    go inc(&wg)  
    go inc(&wg)  
  
    wg.Wait()  
  
    fmt.Println(counter)  
}
```

Здесь, первая горутина, захватившая мьютекс, получает право на работу с `counter`, прибавляя ему 10.000. Далее горутина отпускает мьютекс, и теперь уже вторая горутина захватывает мьютекс, тем самым получая право обработать `counter`. Однако, пока мьютекс не захвачен, горутина ждёт его освобождения, не имея права изменять `counter`, таким образом мы реализуем последовательный доступ к общей памяти из разных горутин.
_

> [!NOTE] С официального сайта
> Programs that modify data being simultaneously accessed by multiple goroutines must serialize such access.

Ситуация, когда происходит одновременное изменение общей памяти несколькими потоками — **состояние гонки**.
<h6>Гонка</h6>
Условие гонки (race condition) — ситуация, при которой один поток изменяет переменную (область памяти) в то время, когда другой поток читает эту же переменную (область памяти).

> [!NOTE] Wikipedia
> **Состояние гонки** ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") race condition), также **конкуренция** — ошибка проектирования [многопоточной](https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C "Многопоточность") системы или приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода. Своё название ошибка получила от похожей ошибки проектирования электронных схем
> 
> Из-за неконтролируемого доступа к общей памяти состояние гонки может приводить к совершенно различным ошибкам, которые могут проявляться в непредсказуемые моменты времени, а попытка повторения ошибки в целях отладки со схожими условиями работы может оказаться безуспешной.

Гонка возникает из-за того, что операция изменения фактически состоит из трёх (наверное): чтение в буфер - изменение - перезапись.

Для устранения гонки при использовании общей памяти следует организовать последовательный доступ к переменным, например, с помощью мьютекса.

Мьютекс (MUTual EXclusion) — тип данных из пакета "sync", имеющий два метода: `Lock()`, `Unlock()`.

Каналы, по своей природе, лишены данной проблемы и потому рекомендуются как средство коммуникации потоков, однако мьютексы минималистичнее, ибо нам не всегда необходимо передать какое-то сообщение (что является основной целью каналов).

Go имеет встроенный детектор состояния гонки, для включения которого достаточно просто добавить флаг `-race` в команду `go run`. Однако, детектор не обнаруживает гонку со 100% вероятностью.
___
<h5>Типовые ошибки</h5>
<h6>Доступ к итератору цикла через замыкание</h6>
```go
func error1() {
	var wg sync.WaitGroup
	wg.Add(10)

	for i := 0; i < 10; i++ {
		go func() {
			defer wg.Done()
			fmt.Println(i)
		}
	}

	wg.Wait()
}
```

Недетерминированность при использовании горутин — важнейшее, что необходимо усвоить.

В цикле с помощью ключевого слова `go` мы отправляем функцию в очередь на выполнение, и, скорее всего, большая часть из этих горутин будет запущена уже после окончания цикла, то есть, когда переменная `i` примет значение 10. Поэтому, скорее всего, большая часть горутин выведет на экран `10`.

Чтобы избежать недетерминированного поведения, мы можем передать `i` как параметр запускаемой функции, тогда функция воспользуется тем значением, которое пришло в аргументе — а это будет копия счётчика `i`  на момент создания горутины.

Вариант исправления 1:
```go
func error1() {
	var wg sync.WaitGroup
	wg.Add(10)

	for i := 0; i < 10; i++ {
		go func(a int) {
			defer wg.Done()
			fmt.Println(a)
		}(i)
	}

	wg.Wait()
}
```

Вариант исправления 2:
```go
func error1() {
	var wg sync.WaitGroup
	wg.Add(10)

	for i := 0; i < 10; i++ {
		i := i
		go func() {
			defer wg.Done()
			fmt.Println(i)
		}
	}

	wg.Wait()
}
```

Здесь внутренняя `i` затеняет внешнюю `i`, и горутина пользуется той `i`, которая "ближе" (по уровню вложенности).

<h6>Использование таймера для синхронизации</h6>
```go
func error2() {
	go func() {
		for i := 0; i < 1_000_000_000; i++ {
			if i % 1000 == 0 {
				fmt.Println(i)
			}
		}
	}()
	
	time.Sleep(1 * time.Second)
}
```

Здесь для синхронизации (ожидания окончания работы всех горутин) используется таймер, что ошибочно, так как мы точно не знаем, когда именно горутины будут запущены. Основная программа с таймером может завершиться раньше завершения остальных горутин, и тогда они будут остановлены, не закончив свою работу.
С другой стороны, горутины могут завершиться раньше истечения таймера, и тогда мы впустую потратим оставшееся время, ожидая.

Исправление:
```go
func error2() {
	var wg sync.WaitGroup
	wg.Add(1)

	go func() {
		defer wg.Done()
		
		for i := 0; i < 1_000_000_000; i++ {
			if i % 1000 == 0 {
				fmt.Println(i)
			}
		}
	}()

	wg.Wait()
}
```

<h6>Отсутствие контроля за завершением потоков</h6>
```go
func error3() {
	f := func(i int) {
		fmt.Println(i)
	}

	for i := 0; i < 10; i++ {
		go f(i)
	}
}
```

Здесь мы не продумываем, как горутины будут завершаться. Из-за этого, мы создаём их и отправляем в очередь на исполнение, а затем программа завершается ещё до начала работы горутин. В целом, это можно отнести и к ошибке синхронизации.

Исправление:
```go
func error3() {
	var wg sync.WaitGroup
	wg.Add(10)

	f := func(i int) {
		defer wg.Done()
		fmt.Println(i)
	}

	for i := 0; i < 10; i++ {
		go f(i)
	}

	wg.Wait()
}
```
___
<h5>Пакет "sync/atomic"</h5>
https://pkg.go.dev/sync/atomic

Пакет "sync/atomic" предоставляет низкоуровневые функции для атомарных операций с переменными.

Пакет используется для потокобезопасного чтения и изменения целых чисел.

В основном, функции данного пакета используются в более высокоуровневых механизмах синхронизации.

Функции пакета sync/atomic можно использовать для счётчиков в многопоточных приложениях.

```go
package main  
  
import (  
    "fmt"  
    "sync"    "sync/atomic"
)  
  
func main() {  
    var c int64  
  
    var wg sync.WaitGroup  
    const N = 100_000  
    wg.Add(N)  
  
    for i := 0; i < N; i++ {  
       go func() {  
          defer wg.Done()  
          atomic.AddInt64(&c, 1)  
       }()  
    }  
  
    wg.Wait()  
    fmt.Println("Счётчик:", c)  
}
```

Операции из пакета sync/atomic реализованы непосредственно в железе (процессоре). Алгоритмы, написанные с помощью атомарных инструкций, поддерживающиеся процессором и гарантированно потокобезопасные, называются lock-free алгоритмами.

Однако атомики нетривиальны и при высокой степени конкурентности кода могут проигрывать обычным мьютексам в эффективности.
___
<h5>Шаблоны проектирования</h5>
В Go, как правило, когда речь идёт о шаблонах, имеют ввиду шаблоны конкурентного кода.

<h6>Fan-Out</h6>
Шаблон **Fan-Out** (распылитель, вентилятор) позволяет распараллелить выполнение заданий по нескольким обработчикам.

Каждый обработчик принимает задания из входного канала и записывает результаты в выходной канал.

Очень важно понимать, каким образом обработчики завершат работу.

Точкой присоединения является метод `Wait()` группы ожидания.

![[Pasted image 20240714232945.png]]

```go
package main

import (
	"log"
	"sync"
)

func generateWork(work []int, wg *sync.WaitGroup) <-chan int {
	ch := make(chan int)

	go func() {
		defer wg.Done()
		defer close(ch)

		for _, w := range work {
			ch <- w
		}
		log.Println("All data written")
	}()

	return ch
}

func fanOut(in <-chan int, name string, wg *sync.WaitGroup) {
	go func() {
		defer wg.Done()

		for data := range in {
			log.Println(name, "processed", data)
		}
	}()
}

func main() {
	var wg sync.WaitGroup
	work := []int{1, 2, 3, 4, 5, 6, 7, 8}

	wg.Add(1)
	in := generateWork(work, &wg)

	wg.Add(3) //nolint:mnd // it's learning code
	fanOut(in, "Alice", &wg)
	fanOut(in, "Jack", &wg)
	fanOut(in, "Bob", &wg)

	wg.Wait()
}
```

Таким образом, шаблон подразумевает, что входящие задания попадают в канал, из которого их считывают рабочие потоки, обрабатывают и пишут результат в результирующий канал.
___
<h5>Fan-In</h5>
Шаблон **Fan-In** (воронка) позволяет объединить результат работы нескольких потоков в один выходной канал.
Данный шаблон может использоваться вместе с шаблоном Fan-Out для мультиплексирования результатов распределённых вычислений.

![[Pasted image 20240715142537.png]]

Имеется множество источников — каналов с заданиями. Задания из них мы должны обрабатывать в одном потоке. Похоже на воронку.

```go
package main

import (
	"fmt"
	"sync"
)

func generateWork(n int) chan int {
	ch := make(chan int)
	go func() {
		defer close(ch)
		ch <- n * n
	}()
	return ch
}

func fanIn[T any](channels ...<-chan T) <-chan T {
	ch := make(chan T)
	var wg sync.WaitGroup
	wg.Add(len(channels))

	for _, c := range channels {
		go func(in <-chan T) {
			defer wg.Done()
			for i := range in {
				ch <- i
			}
		}(c)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	return ch
}

func main() {
	var chans []<-chan int
	for i := 0; i < 10; i++ {
		chans = append(chans, generateWork(i))
	}

	ch := fanIn(chans...)
	for val := range ch {
		fmt.Println(val)
	}
}
```

Здесь, для каждого входного канала мы создаём горутину, которая читает задачи из этого канала и пишет в общий (выходной) канал с задачами.
___
<h5>Pipeline</h5>
Шаблон **Pipeline** (конвейер) состоит из генератора исходных данных и обработчиков (от одного до скольких угодно), выполняющихся последовательно.

Таким образом, результат работы предыдущего этапа конвейера подаётся на вход следующему этапу конвейера.

Генератор и обработчики принимают данные из входного канала и возвращают канал выходных данных. Пример конвейера: процедура ETL.


> [!NOTE] ETL
> **ETL** – общий термин для всех процессов миграции данных из одного источника в другой, который включает в себя:
> - извлечение данных из внешних источников;
> - их трансформация, очистка и обогащение, чтобы они соответствовали потребностям бизнес-модели;
> - их загрузка в хранилище данных.


```go
package main

import "fmt"

type numeric interface {
	int | int32 | int64 | float32 | float64
}

func generateWork(nums ...int) <-chan int {
	out := make(chan int)
	go func() {
		for _, n := range nums {
			out <- n
		}
		close(out)
	}()
	return out
}

func step1[T numeric](in <-chan T) <-chan T {
	out := make(chan T)
	go func() {
		for n := range in {
			out <- n * n
		}
		close(out)
	}()
	return out
}

func step2[T numeric](in <-chan T) <-chan T {
	out := make(chan T)
	go func() {
		for n := range in {
			out <- n * 2
		}
		close(out)
	}()
	return out
}

func main() {
	src := generateWork(1, 2, 3, 4, 5)
	res := step1(step2(step1(step1(src))))

	for val := range res {
		fmt.Println(val)
	}
}

```

Шаблон конвейер — легчайший ^\_^
___
<h5>Контекст</h5>
https://pkg.go.dev/context
Контекст — это пакет стандартной библиотеки (попал туда не сразу, а приблизительно с версии 1.9). 

Пакет контекст содержит единственный тип данных — `Context`.
Этот тип данных предназначен для двух целей:
- Передача в потоки сигналов отмены;
- Передача контекстной информации по цепочке конвейера.

Тип `Context` содержит единственный метод `Done()`, который возвращает канал, который закрывается при вызове функции отмены.
Функция отмены может вызываться вручную, по таймауту и по времени.

Также объект контекста содержит таблицу с контекстной информацией в поле `Value`.

Контекст работает аналогично шаблону с каналом отмены.

> Контекст воспринимается начинающими писателями на Go как волшебная штука, однако вы уже знаете, что в Go с магией туго. Контекст — не волшебная штука, и он не может ничего самостоятельно отменить.

Контекст — это интерфейс, обладающий несколькими методами, важнейшим из которых является метод `Done()`:
`Done() <-chan struct{}`

Когда мы завершаем контекст, канал, возвращаемый методом `Done()`, будет закрытым. Следовательно, мы получим возможность из него что-либо прочесть, и этим чем-либо будет дефолтное значение для типа канала. Пока же контекст не завершён, канал открыт и пуст, и мы не можем из ничего ничего прочесть.

<h6>Для чего появился контекст?</h6>
Контекст был придуман в компании Google в виде дополнительного пакета к Go (позже контекст вошёл в стандартную библиотеку).

Идея была следующая.
В Google озаботились проблемой: многие запросы на поиск оказывались невостребованными (пользователь закрыл сайт, автоматический запрос закрыл соединение, обрыв соединения и т.д.), а каждый запрос потреблял немалое количество ресурсов.

Когда мы выполняем поисковый запрос, Google начинает одновременный поиск во множестве источников: сайты, картинки, youtube, товары, реклама и т.д.

В то же время поиск должен быть быстрым. Например, поиск по видео является долгим процессом, поэтому такой поиск может иметь дедлайн — останавливаем поиск на том, что успели найти до окончания дедлайна.

В таких условиях, если пользователь закрыл страницу, нужно бы отменить все отправленные нами по разным источникам запросы. Таким образом, суть в том, что нам необходимо уметь отменить все запущенные нами операции с помощью одного централизованного сигнала. Для этого используется пакет контекст.

Идея контекста в том, чтобы передавать во все запускаемые нами операции небольшой объект контекста, содержащий флажок — признак валидности текущего запроса (этот флажок — канал, возвращаемый  функцией `Done()`).

Если канал не закрыт — контекст (а вместе с ним и запрос) всё ещё валиден, и имеет смысл продолжать выполнение запроса. В противном случае мы останавливаем обработку запроса.

Таким образом, все наши функции принимают дополнительный параметр — контекст. Функция должна проверять, валиден ли контекст, и если нет — завершать свою работу.

```go
func worker(ctx context.Context, in <-chan  string, out chan<- string) {
	for {
		select {
		case <-ctx.Done():
			fmt.Println("context was done")
			close(out)
			return
		case val := <-in:
			fmt.Println("Handling message:", val)
			out <- fmt.Sprintf("Message '%s' is handled", val)
		}
	}
}
```

Помимо функциональности флажка отмены, в контексте можно хранить дополнительную информацию:
`ctx = context.WithValue(ctx, "key", "value")`
Однако не стоит хранить в контексте бизнес-данные, для этого используем отдельные явные сущности. В контексте стоит хранить мета-информацию.

Например, в больших распределённых микросервисных системах, в контексте может храниться уникальный идентификатор запроса `correlationId` для трассировки запроса.