План занятия:
- Источники информации
- Введение
- Структура каталогов приложения
- Структура пакетов приложения
- Архитектура приложения
- Чистая архитектура
- Принципы **SOLID** в Go
- Монолит vs микросервисы
___
<h5>Источники информации</h5>
Книга **Clean Architecture** (Robert C. Martin)

**Ultimate Go Training** by Bill Kennedy
https://www.ardanlabs.com/ultimate-go/

**The Go Programming Language** (Alan A. A. Donovan, Brian W. Kernighan)

Книга **Microservices Patterns** (Chris Richardson)

https://martinfowler.com/microservices
___
<h5>Введение</h5>
**Проектирование и разработка ПО** — инженерная дисциплина, а не наука. Это означает, что нет железобетонных аксиом и теорема, а значит нет и единственного верного решения.

Мы обладаем сводом знаний, лучших практик, рекомендаций опытных специалистов, и эти компоненты могут противоречить друг другу.

Однако существуют рекомендации, подкреплённые разумными аргументами, и их можно рассматривать как правила.

Для каждого проекта следует выбрать набор правил, которыми будут руководствоваться все члены коллектива. Эти правила, может, и не обеспечат лучшее решение, но привнесут в проект стандарт работы, единообразие.

При очевидной неудаче, правила стоит пересмотреть.
___
<h5>Структура каталогов приложения</h5>
Все исполняемые пакеты размещаются в подкаталогах каталога "project/cmd" (в отдельных каталогах).

Общая кодовая база подключаемых пакетов размещается в подкаталогах каталога "project/internal" или "project/pkg".

Может потребоваться защитить некоторые подключаемые пакеты от импорта из внешних проектов. Такие пакеты следует разместить в подкаталогах каталога "project/internal". Компилятор не позволит импортировать такие пакеты снаружи каталога "project/".

Всё это — согласно популярному на гитхабе шаблону go-standard-project-layout (или как-то так).

Подключаемый пакет не должен завершать программу (т.е. не должен брать на себя управление приложением). То есть всё, что находится в подкаталогах "pkg" или "internal" не должно содержать `log.Fatal` и подобных конструкций, завершающих программу.
___
<h5>Структура пакетов приложения</h5>
Структура пакетов приложения должна повторять структуру самого приложения, при взгляде на структуру пакетов, должно быть понятно назначение приложения.

Если приложение имеет кэш, то должен существовать пакет для кэша. Если у приложения есть функциональность отчётов, должен существовать пакет для отчётов.

Вследствие этого, такие архитектуры как MVC, MVVM и иные плохо подходят, так как представляют приложение в виде обезличенных слоёв.

Также плохим решением является использование фреймворков, которые навязывают собственную структуру пакетов.

Подробнее: книга **Clean Architecture**, глава 21.
___
<h5>Архитектура приложения</h5>
Хорошая статья: https://martinfowler.com/architecture/

**Архитектура программного обеспечения** — совокупность важнейших решений об организации программной системы (Википедия).

Важнейшие решения включают в себя:
- Выбор технологического стека
- Использование стороннего ПО (БД, очереди, кэши и пр.)
- Договорённость о методике разработки (взаимодействие, стандарты кодирования и пр.)
- Принцип организации кода (структура пакетов, DI)
- Топология приложения

Архитектура влияет на следующие моменты:
- **Разработка**. Архитектура (как набор решений) должна упрощать и удешевлять разработку.
- **Развёртывание**. Архитектура должна способствовать максимально простому процессу развёртывания ПО.
- **Эксплуатация**. На этапе эксплуатации ПО влияние архитектуры минимально.
- **Сопровождение и развитие**. Архитектура должна упрощать процессы добавления нового функционала и поиска и исправления ошибок.
- Хорошая архитектура сосредоточена на политиках (policy, бизнес-правилах) и не зависит от деталей реализации (топология, СУБД, очереди, JSON, REST и т.д.)
<h6>Архитектор ПО</h6>
**Архитектор ПО** — опытный программист, задача которого — сделать разработку и сопровождение продукта максимально дешёвой. Архитектор ПО решает бизнес-задачи!

Хороший архитектор оставляет как можно большее количество опций доступными. 

То есть, хороший архитектор максимально откладывает принятие конкретных решений, таких как:
- использование микросервисной архитектуры
- использование конкретной СУБД
- использование конкретных очередей, кэшей, фреймворков и пр.

Это позволяет сосредоточиться на политиках (бизнес-логике приложения) и отложить принятие конкретных решений (соответствующие затраты на внедрение и сопровождение). Зависимость внедряется, только если она нужна здесь и сейчас.
___
<h5>Чистая архитектура</h5>
Дядя Боб говорит, что архитектуру приложения можно представить в виде концентрических окружностей, и чем окружность ближе к центру, тем она является более важной частью приложения.

Чистая архитектура говорит о том, что ПО состоит из слоёв:
- Внутренние слои: политики (бизнес-логика)
- Внешние слои: детали реализации

Внутренние слои не знают о внешних, и не зависят от внешних.
Бизнес-логике всё равно, через какие шлюзы мы будем получать данные и отдавать их.

Внутренние слои (бизнес-логика) являются довольно стабильными, в то время как внешние слои сильнее подвержены изменениям (мы можем заменить БД, очередь сообщений и т.д.)

Поэтому в центре — элементы, которые почти не меняются. Чем дальше от центра, тем более изменчив элемент.

Данная схема базируется на ООП, для Go требуется интерпретация.

![[Pasted image 20240804134527.png]]
___
<h5>Принципы SOLID в Go</h5>
<h6>SRP (Single Responsibility Principle)</h6>
Принцип единственной ответственности — у пакета должен быть единственный источник изменений.

Смысл принципа в том, что должен существовать только один пользователь, который может инициировать изменения в пакете.

Пользователем может выступать:
- Пользователь ПО
- Программист (пользователь API)
- Компонент ПО
- и т.д.

Если пакет используется разными пользователями (компонентами ПО), задачи которых разнонаправлены, то эти пользователи могут потребовать несовместимые или деструктивные друг для друга изменения.

Решение заключается в том, чтобы разделить такой код на несколько пакетов, чтобы правило о наличии у пакета единственного источника изменений стало выполняться.
<h6>OCP (Open Close Principle)</h6>
Принцип открытости/закрытости — пакет должен быть открыт для расширения (функциональности), но закрыт для изменения.

Смысл принципа состоит в том, что пакет должен быть спроектирован и реализован таким образом, чтобы пользователю не пришлось модифицировать его алгоритмы и структуры данных для выполнения своих задач.

Чтобы достичь этого, пакет должен предоставлять пользователю функциональные блоки — модули — которые можно комбинировать между собой для решения задачи.

Антипаттерном является попытка думать за пользователя пакета.

Пакет должен предоставлять набор строительных блоков и возвращать сырые данные.

Примером выполнения OCP является стандартная библиотека Go :)
<h6>LSP (Liskov substitution principle)</h6>
Принцип подстановки Барбары Лисков — функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.

Смысл принципа состоит в том, что если функция принимает в качестве аргумента некоторых класс, то она должна принимать и класс-потомок.

Или, говоря иначе, один объект должно быть возможно заменить другим, имеющим аналогичные возможности.

В Go нет наследования, но принцип LSP легко выполняется за счёт интерфейсов.
<h6>ISP (Interface Segregation Principle)</h6>
Принцип разделения интерфейса — много маленьких интерфейсов лучше, чем один большой.

Смысл принципа состоит в том, что следует проектировать интерфейсы таким образом, чтобы клиенты могли использовать только минимальную реализацию, не содержащую лишних функций, которые клиенту не нужны.

> [!NOTE] +мудрость
> Программные сущности не должны зависеть от методов, которые они не используют (Р. Мартин)

Толстые интерфейсы необходимо разделять на более маленькие и специфические, чтобы реализации маленьких интерфейсов знали только о методах, которые необходимы им в работе. При изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют (Википедия).
<h6>DI (Dependency Inversion Principle)</h6>
Принцип инверсии зависимостей — направление зависимостей обратно направлению потоков выполнения кода.

Смысл принципа состоит в том, что компоненты бизнес-логики (политик) не должны зависеть от менее важных компонентов (деталей реализации — БД, очереди, фреймворки, GUI и т.д.).

Если такая зависимость существует, то её необходимо переработать, добавив интерфейс.
___
<h5>Монолит vs Микросервисы</h5>
<h6>Монолит</h6>
Монолитное приложение характеризуется одним процессом и одним хранилищем данных.

Плюсы монолита:
- разработка быстрее и дешевле, особенно на начальных этапах,
- производительность приложения значительно выше,
- ментальная модель проще (до некоторого момента),
- простое обеспечение целостности и согласованности данных.

Минусы монолита:
- высокая степень взаимного влияния сотрудников не позволяет эффективно масштабировать коллектив,
- для очень больших приложений может быть слишком высокая сложность ментальной модели приложения.

Начинать разработку приложения практически всегда следует с монолита.
<h6>Микросервисы</h6>
Микросервисы предполагают разделение приложения на большое количество отдельных служб (процессов), каждая из которых имеет собственную БД. Службы взаимодействуют по сети, используя API (обычно HTTP REST API). Часто такое взаимодействие асинхронно.

Плюсы микросервисов:
- наиболее популярный на сегодня способ масштабировать разработку при росте численности коллектива (см. "Мифический человеко-месяц"),
- позволяют при определённых условиях управлять сложностью проекта (плохая архитектура затруднит управление сложностью при любой топологии информационной системы).

Микросервисный подход автоматически означает, что приложение становится распределённым, что влечёт за собой целый ряд проблем.

Минусы микросервисов:
- значительно более усложнённая и дорогая инфраструктура: обнаружение служб, DNS, мониторинг, развёртывание и тд,
- значительно более дорогая разработка в пересчёте на одну новую функцию за счёт необходимости писать и документировать API (со временем это может измениться),
- более сложные технологии разработки: асинхронное взаимодействие требует разработки менеджера распределённых запросов, очередей сообщений и тд,
- сложности при обеспечении согласованности данных: БД разных микросервисов зачастую содержат зависящие друг от друга данные; изменение одной БД влечёт необходимость изменения другой для обеспечения целостности; механизм транзакций недоступен,
- взаимодействие по сети предполагает сетевые ошибки, которые нужно учитывать,
- и многое другое, что следует из природы распределённых систем (отладка и тестирование, профилирование, журналирование, организация среды разработки и тд).

Для внедрения микросервисной архитектуры, я говорю вам: Должна быть **веская** причина.