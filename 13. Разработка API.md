План занятия:
- Понятие API
- REST API
- Middleware
- Тестирование API
- Пакет API
- Контекст в HTTP-обработчиках
- Авторизация
- Документирование API
___
<h5>Понятие API</h5>
![[Без имени-1.png]]

Для общения клиента с нашей системой, а также для общения микросервисов нашей системы между собой используется API. Каждый микросервис предоставляет API, предлагающий способы обращения к себе.

Кроме того, обычно существует отдельный компонент — API Gateway, являющийся точкой входа запроса клиента внешней системы в нашу систему.

**API (application programming interface, программный интерфейс приложения)** — описание способов (наборов классов, процедур, функций, структур или констант), которыми одна компьютерная программа может взаимодействовать с другой программой (*Википедия*).

API — единственный способ взаимодействия с приложением. API может существовать на уровне приложения, пакета, подсистемы, базы данных (схема БД) и прочего. Целью нашего изучения является API на уровне приложения.

API приложения служит двум основным целям:
- Взаимодействие с внешними системами (доступен снаружи) — **public API**
- Предоставление данных клиентским приложениям (нашим веб-, мобильные приложения) (доступен только изнутри системы) — **private API**
___
<h5>REST API</h5>
**REST** (Representational State Transfer — «передача состояния представления») — _архитектурный стиль взаимодействия компонентов распределённого приложения в сети._ Взаимодействие между сервером и клиентом представляет собой HTTP-запрос, где необходимые данные передаются в качестве параметров запроса, причем в том же виде, что и сами данные.

### Принципы REST и RESTful приложений:

1. **Клиент-серверная архитектура**.
2. **Отсутствие состояния**. Все запросы от клиента должны быть составлены так, чтобы сервер получил всю необходимую информацию для выполнения запроса, чтобы и сервер, и клиент могли "понимать" любое сообщение, не опираясь при этом на предыдущие сообщения.
3. **Кэширование**. Клиенты могут выполнять кэширование ответов сервера. У тех, в свою очередь, должно быть явное или неявное обозначение как кэшируемых или некэшируемых, чтобы клиенты в ответ на последующие запросы не получали устаревшие или неверные данные. Правильное использование кэширования помогает полностью или частично устранить некоторые клиент-серверные взаимодействия, ещё больше повышая производительность и расширяемость системы.
4. **Единообразие интерфейса**. Должен существовать определённый интерфейс, с помощью которого клиент будет всегда понимать, в каком формате и на какие адреса ему нужно слать запрос, а сервер, в свою очередь, понимать, в каком формате ему следует отвечать на запросы клиента.
5. **Слои**. Под слоями подразумевается иерархическая структура сетей. Иногда клиент может общаться напрямую с сервером, а иногда — просто с промежуточным узлом. Применение промежуточных серверов способно повысить масштабируемость за счёт балансировки нагрузки и распределённого кэширования.
6. **Код по требованию** (необязательное ограничение). Клиент может расширять свою функциональность, за счет загрузки кода с сервера в виде апплетов или сценариев.

В современном представлении, REST API состоит из следующих компонентов:
- Клиент-серверная архитектура;
- Протокол HTTP для взаимодействия клиента и сервера;
- Набор конечных точек API, определённых с помощью адреса, параметров и методов (глаголов) HTTP;
- Схема именования: коллекция — ресурс;
- Маршрутизатор запросов;
- Набор промежуточного ПО (middleware);
- Сериализация данных в формате JSON (реже XML);
- Клиент — браузер, мобильное приложение, другой сервис и т.д.

Протокол HTTP имеет 6 основных типов методов, каждый из которых предназначен для определённого действия:
- **GET** — получить данные;
- **POST** — создать запись;
- **OPTIONS** — получить заголовки и возможные команды;
- **PUT** — заменить (обновить полностью);
- **PATCH** — обновить частично;
- **DELETE** — удалить.
Поскольку смысл этих глаголов размыт и общепринятых схем нет, то выбор методов HTTP для эндпоинтов API остаётся на усмотрение разработчика / соглашений в команде / усмотрение аналитика / ...

<h6>Схема именования</h6>
Крайне важным является разработка схемы имён эндпоинтов API. Имена должны быть понятны и логичны, соответствовать REST'у.

Нужно принять следующие решения:
- используемые методы HTTP
- версионирование API
- различные схемы для public/private
- имена для действий (new, delete, ...) или их отсутствие
- формат ответов, сопоставление ошибок и кодов ответа HTTP

Пример:
- `GET /api/private/v2/books/{id}`
- `POST /api/private/v2/books`
- `DELETE /api/private/v2/books/{id}`

Необходимо также решить, как передавать параметры: в query path (`../type/books/23`), в виде query params (`?type=books`) или в теле запроса (`{"type": "books"}`).

`api.go`:
```go
package main  
  
import (  
    "encoding/json"  
    "github.com/gorilla/mux"    
    "net/http"
)  
  
type API struct {  
    router *mux.Router  
}  
  
func (api *API) Endpoints() {  
    api.router.Use()  
    api.router.HandleFunc("/api/v1/books", api.books).Methods(http.MethodGet)  
    api.router.HandleFunc("/api/v1/books", api.newBook).Methods(http.MethodPost)  
    api.router.HandleFunc("/api/v1/books/{id}", api.deleteBook).Methods(http.MethodDelete)  
}  
  
func (api *API) books(w http.ResponseWriter, r *http.Request) {  
    err := json.NewEncoder(w).Encode(books)  
    if err != nil {  
       http.Error(w, err.Error(), http.StatusInternalServerError)  
       return  
    }  
}  
  
func (api *API) newBook(w http.ResponseWriter, r *http.Request) {  
    var b book  
    err := json.NewDecoder(r.Body).Decode(&b)  
    if err != nil {  
       http.Error(w, err.Error(), http.StatusInternalServerError)  
       return  
    }  
    books = append(books, b)  
}  
  
func (api *API) deleteBook(w http.ResponseWriter, r *http.Request) {  
  
}
```

`middleware.go`:
```go
package main  
  
import (  
    "net/http"  
)  
  
func headersMiddleware(next http.Handler) http.Handler {  
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {  
       w.Header().Set("Content-Type", "application/json; charset=utf-8")  
       next.ServeHTTP(w, r)  
    })  
}
```

`server.go`:
```go
package main  
  
import (  
    "github.com/gorilla/mux"  
    "log"    
    "net/http"
)  
  
type server struct {  
    api    *API  
    router *mux.Router  
}  
  
func main() {  
    srv := new(server)  
    srv.router = mux.NewRouter()
    srv.router.Use(headersMiddleware)  
    srv.api = &API{router: srv.router}  
    srv.api.Endpoints()  
  
    log.Fatal(http.ListenAndServe(":8081", srv.router))  
}  
  
type book struct {  
    Name   string  
    Author string  
}  
  
var books = []book{  
    {  
       Name:   "Жук в муравейнике",  
       Author: "Братья Стругацкие",  
    },  
}
```

___
<h5>Middleware</h5>
**Middleware** (посредник, обёртка) — функция, которая вызывается для каждого HTTP-запроса и предназначена для выполнения системных задач (не бизнес-логика).

Примеры задач, выполняемых middleware: авторизация, журналирование запросов, поддержка активной сессии и т.д.

Посредник принимает в качестве аргумента обработчик запроса и возвращает также обработчик.

Логика работы посредника: вернуть функцию обработчик, которая:
1. Каким-либо образом обрабатывает запрос
2. Передаёт управление следующему обработчику (взятому из аргумента функции-middleware)

```go
func middleware(next http.Handler) http.Handler {  
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {  
       log.Println("Middleware: Пришёл запрос")  
       next.ServeHTTP(w, r)  
    })  
}
```
___
<h5>Модульное тестирование API</h5>
Тестирование API сводится к тесту методов-обработчиков. Перед запуском тестов в функции `TestMain()` нужно создать объект API и связать URL с обработчиками.

Схема та же — request, responseRecorder, отправляем свои данные, получаем результат работы обработчика и сравниваем с ожидаемым ответом.

Зависимости стоит имитировать.
___
<h5>Пакет API</h5>

> [!NOTE] Как организовать множество обработчиков?
> Обычно API оформляется в виде отдельного пакета (пакет — набор логически связанного кода).
> 
> Как правило, мы создаём структуру `Api`, методами которой делаем обработчики запросов. Полями структуры являются внешние зависимости (соединение с БД, логгер, очереди сообщений и т.д.).

Рекомендуется реализовать API в виде самостоятельного пакета. Типом данных для API чаще всего является структура, методы которой являются обработчиками запросов. Поля структуры содержат внешние зависимости: 
- маршрутизатор запросов
- базы данных
- журнал
- служба кеширования
- иные службы

Таким образом, API представляется в виде объекта в ООП-стиле. Объект API разумно сделать подчинённым объекту сервера (службы), представляющего собой всё приложение или службу (микросервис).

Сервер создаёт API с помощью функции-конструктора, передавая внешние зависимости.\*

\* P.S. Всё сказанное выше является личным взглядом лектора на проектирование.

`server.go`:
```go
package main  
  
import (  
    "2-api/pkg/api"  
    "log"    
    "net/http"
)  
  
type server struct {  
    api *api.API  
}  
  
func main() {  
    srv := new(server)  
    srv.api = api.New()  
  
    err := http.ListenAndServe(":8082", srv.api.Router())  
    if err != nil {  
       log.Fatal(err)  
    }  
}
```

`api.go`:
```go
package api  
  
import (  
    "github.com/gorilla/mux"  
    "github.com/gorilla/sessions"    
    "net/http"
)  
  
type API struct {  
    router *mux.Router  
    store  *sessions.CookieStore  
}  
  
func New() *API {  
    api := API{  
       router: mux.NewRouter(),  
       store:  sessions.NewCookieStore([]byte("secret_password")),  
    }  
  
    api.endpoints()  
  
    return &api  
}  
  
func (api *API) Router() *mux.Router {  
    return api.router  
}  
  
func (api *API) endpoints() {  
    api.router.HandleFunc("/api/v1/books", api.books).Methods(http.MethodGet, http.MethodOptions)  
    api.router.HandleFunc("/api/v1/newBook", api.newBook).Methods(http.MethodPost, http.MethodOptions)  
}
```

`books.go`:
```go
package api  
  
import (  
    "encoding/json"  
    "net/http"
)  
  
func (api *API) books(w http.ResponseWriter, r *http.Request) {  
    err := json.NewEncoder(w).Encode(books)  
    if err != nil {  
       http.Error(w, err.Error(), http.StatusInternalServerError)  
       return  
    }  
}  
  
func (api *API) newBook(w http.ResponseWriter, r *http.Request) {  
    var b book  
    err := json.NewDecoder(r.Body).Decode(&b)  
    if err != nil {  
       http.Error(w, err.Error(), http.StatusInternalServerError)  
       return  
    }  
    books = append(books, b)  
}  
  
type book struct {  
    Name   string  
    Author string  
}  
  
var books = []book{  
    {  
       Name:   "Жук в муравейнике",  
       Author: "Братья Стругацкие",  
    },  
}
```
___
<h5>Контекст в HTTP-обработчиках</h5>
Контекст иммутабелен — неизменяем. Чтобы модифицировать, нужно создать на его основе новый, с необходимыми настройками.

Контекст в HTTP-обработчиках используется для двух целей:
- отмена цепочки действий (обработчик - бизнес-логика - БД)
- передача данных запроса, не являющихся частью бизнес-логики (ID запроса, IP-адрес и т.д.)

Для отмены следует использовать контекст с таймаутом или дедлайном.

Для добавления в контекст нового значения или нового канала отмены необходимо создать производный контекст. Производные контексты образуют иерархию.

В качестве базового контекста лучше всего использовать контекст запроса, при использовании в мидлвэйр необходимо вызывать следующий обработчик так:
```go
next.ServeHTTP(w, r.WithContext(ctx))
```

Также можно использовать middleware, который выполняет необходимые действия с контекстом (добавляет значения) и вызывает следующий обработчик, передавая запрос в виде `r.WithContext()`.
```go

import "github.com/google/uuid"

func requestIDMiddleware(next http.Handler) http.Handler {  
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {  
       ctx := context.WithValue(r.Context(), "request_id", uuid.New())  
       next.ServeHTTP(w, r.WithContext(ctx))  
    })  
}
```

 Литература: https://habr.com/ru/post/455302/
  ___
 <h5>Авторизация</h5>
 Аутентификация и авторизация — процесс подтверждения личности пользователя и его прав на доступ к запрашиваемому ресурсу.

Аутентификация проверяет, что вы тот, кем вы представляетесь.

Авторизация проверяет, есть ли у вас права на раздел, к которому вы запрашиваете доступ.

При доступе к API процесс обычно выглядит следующим образом:
- Вызов обработчика аутентификации
- Отправка в него учётных данных
- Получение в ответе кода доступа
- Отправка полученного кода вместе с запросом к API

Обычно, наш пользователь единожды проходит аутентификацию и получает в ответ какой-нибудь артефакт (например, токен). После этого, с каждым новым запросом пользователь передаёт этот артефакт серверу (обычно в качестве HTTP-заголовка).

Таким кодом (артефактом) может выступать:
- Строка или число (на основе своей реализации)
- Сгенерированное Cookie (с помощью специального пакета)
- JSON Web Token (JWT) (с помощью специального пакета)

<h6>Авторизация с помощью идентификаторов сеанса</h6>
Самый прозрачный вариант. При успешной аутентификации, сервер выдаёт клиенту сгенерированный номер сеанса, который впоследствии передаётся клиентом в виде заголовка запроса при доступе к API.

Для использования механизма сессий необходимо:
- Создать хранилище номеров сеансов с информацией о пользователе и его правах доступа
- Создать обработчик аутентификации и генерации кода сеанса
- Разработать middleware проверки кода сеанса
- На клиенте: организовать хранение кода сеанса и передачу его в составе запроса

Однако, на мой взгляд, это не слишком хорошо ложится на принцип REST, так как при использовании идентификаторов сеанса, сервер должен хранить информацию о состоянии клиента.

<h6>Авторизация с помощью сессий</h6>
https://github.com/gorilla/sessions

Сессии — информация, предоставленная пользователю API в виде cookie. Сессии хранятся в специальном хранилище на сервере и содержат информацию о пользователе, его правах доступа и времени действия сеанса.

Для использования механизма сессий необходимо:
- Создать хранилище сессий
- Создать обработчик аутентификации
- Разработать middleware проверки сессий
- На клиенте: организовать хранение сессии-cookie и передачу его в составе запроса

<h6>Авторизация с помощью JWT</h6>
https://github.com/dgrijalva/jwt-go

JWT (json web token) — зашифрованный объект JSON, содержащий набор сведений о пользователе API (утверждения, claims) вместе со служебной информацией (срок годности токена и пр.)

JWT состоит из 3-х частей:
- Заголовок
- Данные (утверждения)
- Цифровая подпись (подписывает сервер, когда выдаёт токен)
JWT закодирован по алгоритму BASE64 и в итоге представляет собой строку из трёх частей. Сам токен легко можно раскодировать и прочитать, но его нельзя незаметно модифицировать, так как он защищён цифровой подписью.

Цифровая подпись — это хеш всей остальной части токена.

При аутентификации, сервер выдаёт пользователю JWT-токен с набором прав этого пользователя. 
Пользователь передаёт токен при каждом запросе к серверу.
Сервер проверяет цифровую подпись токена с помощью мастер-пароля (с помощью которого цифровая подпись была сформирована). 
Если проверка пройдена, сервер верит всем утверждениям, закодированным в токене.

Для хранения мастер-пароля обычно используются инструменты для хранения чувствительных данных, например Vault.

Но с JWT-токеном возможна компрометация токена, то есть утечка мастер-пароля.
___
<h5>Документация API</h5>
Важно помнить, что нашим API будут пользоваться другие разработчики. Для этого API должен быть понятным, а для этого он должен быть задокументированным. 
**Хороший API всегда задокументирован.**

Существуют несколько стандартов документирования API, самый известный — OpenAPI (https://swagger.io/specification/)

Для Go существуют библиотеки, автоматические генерирующие документацию к нашему API на основе аннотаций в коде.

Для документирования можно воспользоваться утилитами Swagger (позволяет локально развернуть сервер документации), Postman (конвертация коллекций Postman'а в документацию Swagger) или иными.

Также существует подход в разработке, называемый Spec-first — сначала разрабатывается спецификация API, а затем под неё разрабатывается сам API.