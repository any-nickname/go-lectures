План занятия:
- Определение и примеры
- Структуры данных в Go
- Связные списки (List)
- Бинарные деревья поиска
- Стеки и очереди

*Приятное замечание: я знаю всё, что рассказывает спикер  ^^*
___
<h5>Определение</h5>
**Структура данных** — программная единица, позволяющая хранить и обрабатывать множество однотипных и/или логически связанных данных.

Примеры:
- строки, массивы, срезы, ассоциативные массивы
- связные списки
- стеки и очереди
- деревья
- графы в виде матриц или списков смежности
___
<h5>Структуры данных в Go</h5>
В стандартной поставке языка содержатся следующие структуры данных (все другие типовые структуры данных доступны во внешних пакетах).

Встроенные типы данных:
- массивы (array)
- срезы (slice)
- ассоциативные массивы (map)

Стандартная библиотека:
- min-куча (heap) — пакет "container/heap"
- двусвязный список (linked list) — пакет "container/list"
- кольцевой список (ring) — пакет "container/ring"
___
<h5>Массив</h5>
Спецификация: https://golang.org/ref/spec#Array_types

Свойства:
- массив занимает последовательную область памяти
- доступ к произвольному элементу за O(1), добавление элемента происходит за О(n)
- элементы массива имеют индексы от 0 до len(a)-1, длина массива — часть самого типа данных
- индексы не могут быть отрицательными
- массив всегда одномерен, однако можно объявить тип элемента массивом, создавая многомерные массивы

```go
var a [2]int         // массив целых чисел с двумя элементами
var b [3][3]float32  // двумерный массив вещественных чисел 3*3
var c [5]map[int]bool // массив из пяти словарей
```

Добавить элемент в массив очень непросто, так как компьютер, в общем случае, не может гарантировать, что кусок памяти, занимаемый массивом, имеет рядом дополнительные свободные ячейки. Таким образом, чтобы массив остался неразрывной последовательностью ячеек в памяти, в худшем случае придётся копировать весь массив целиком в новую область памяти. Сложность такого действия O(n), ибо нам нужно обработать все n элементов массива.
Только вот в массив нельзя добавлять элементы.... ) Дмитрий Титов, ты чево? Видимо, речь про слайсы.

**Длина массива является частью типа данных**. Нет типа данных "Go-массив из элементов типа int". Есть тип данных "Go-массив из 20 элементов типа int".
`[5]int` и `[20]int` — разные типы данных!
___
<h5>Слайс, срез, "массив"</h5>
*a.k.a. "динамический массив", радикально отличающийся от массива*
Спецификация: https://golang.org/ref/spec#Slice_types

Слайс, в отличие от массива, содержит метаданные. Слайс — структура из трёх полей: длина, ёмкость и ссылка на массив. Слайс построен поверх массива. В этом смысле, слайс является ссылочным типом, так как он содержит указатель на массив, и по умолчанию слайс равен nil.
Следовательно, если мы присвоим один слайс другому, то мы не скопируем данные. Мы скопируем указатель на массив.
```go
a := []int{ 1, 2, 3 }
b := a
```
Мы не скопировали данные, `b` содержит указатель на тот же массив, что и `a`. Если мы поменяем `b`, изменения отобразятся и в слайсе `a`.
```go
a := []int{1, 2, 3}

b := a
b[1] = -50

fmt.Println(a) // [1 -50 3]
```

**Забава.** Если внутри вложенной функции применить к слайсу-аргументу функцию `append`, то исходный слайс (извне функции) не изменится. Но если изменить какой-то конкретный элемент слайса-аргумента внутри вложенной функции, то исходный слайс изменится! Почему?

Изменяется:
```go
package main

import (
	"fmt"
)

func changeSlice(s []int) {
	s[0] = -777
}

func main() {
	a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}
	changeSlice(a)
	fmt.Println(a)
}
```

Не изменяется:
```go
package main

import (
	"fmt"
)

func changeSlice(s []int) {
	s = append(s, -777)
}

func main() {
	a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}
	changeSlice(a)
	fmt.Println(a)
}
```

Как тебе наверняка известно, слайс может динамически расширяться. На деле же, когда ёмкость внутреннего массива превышается, выделяется память под новый, больший массив, и все элементы старого массива копируются туда + новый элемент. Коэффициент расширения массива падает с ростом ёмкости массива. 
___
<h5>Массив vs Слайс</h5>
Массив — это просто область памяти. Слайс — более сложная вещь, структура.
Поэтому, если мы создадим массив из нуля элементов, он не будет занимать **вообще никакой** памяти, в отличие от слайса.

Массивы используются довольно редко. Они могут быть полезны при работе, например, с бинарными протоколами. Например, TCP шлёт данные потоком, не делая перерывы или пустые места между порциями информации. Поэтому создаётся договорённость, сколько байтов занимает заголовок, сколько тело и т.д. Чтобы считать определённую порцию информации фиксированной длины, и используется массив.
___
<h5>Развенчание мифов о "лёгкости" слайсов!</h5>
Создадим слайс с миллиардом элементов типа int:

```go
var slice = make([]int, 1_000_000_000)

func main() {
	newSlice := append(slice, 25)
	newSlice[1] = 10
	x, y := size.Of(slice), size.Of(newSlice)
	fmt.Println(x/1024/1024/1024) // 7 гигабайт
	fmt.Println(y/1024/1024/1024) // 9 гигабайт
}
```

Исходный слайс весил 7 гигабайт, но при добавлении всего 1 числа он увеличил свой размер на 2 гигабайта! Это тяжело.
Двумя слайсами нам удалось занять **целых 16 гигабайт** оперативной памяти.

Для удаления ненужного массива запустится garbage collector, который остановит всю программу (**stop the world**), запустит механизм "**mark and sweep**".

Таким образом, добавление всего 1 числа в массив вызовет выделение 9 гигабайт памяти и запуск garbage collector'а, который запускается тогда, когда количество занятой оперативной памяти превышает объём активной памяти (1 миллиард байт) **в 2 раза**.
В общем, трагедия.
___
<h5>Забава со срезами в слайсах</h5>

```go
package main

import (
	"fmt"
)

func main() {
	s1 := []int{1, 2, 3, 4, 5}
	
	s2 := s1[2:4]
	
	s2[0] = 10
	fmt.Println("s1:", s1) // s1: [1 2 10 4 5]
}
```

Мы меняем слайс 2, но меняется слайс 1. Дело в том, что оба слайса ссылаются на одну и ту же область памяти, где находится массив.
<h5>spread-оператор</h5>
Оператор расширения:
```go
a = append(a, b...) // b... - оператор расширения (раскрытия (шо))
```
___
<h5>Разница в создании слайсов</h5>
Слайсы можно создать с помощью:
- `make([]int, 3)`
- `[]int{1, 2, 3}`
- `var a []int; a = append(a, 1); a = append(a, 2), a = append(a, 3);`

Аллоцировать конкретную память нужно, когда известно точное количество элементов. Тогда мы избавимся от пересоздания новых массивов при использовании `append` и давления на сборщик мусора.
**Мудро!**
___
<h5>Хэш-таблица</h5>
Спецификация: https://golang.org/ref/spec#Map_types

**(must have)** Статья в официальном блоке: https://blog.golang.org/maps

Хэш-таблица — неупорядоченный набор пар ключ-значения. При каждом новом обходе, порядок не гарантирован.
Неупорядоченность хэш-таблицы не организована намеренно, а это связано с тем, как хэш-таблица организована внутри.

Вставка, удаление и поиск любого элемента осуществляется за O(1), в среднем.
**В худшем случае** все выполняются за O(n). Худший случай достигается тогда, когда значение хэш-функции одинаково для всех ключей, тогда все значения попадают в один бакет.

Хэш-таблица для каждого ключа вычисляет значение хэш-функции, которое является указателем на значение для этого ключа.

Иногда хэш-таблицу приходится перестраивать, из-за чего малое время генераций нельзя гарантировать.

Время вычисления хэш-функции не обязательно мало, хотя и постоянно.

Обход хэш-таблицы осуществляется с помощью оператора `range`. В целом, для хэш-таблицы необязательно хранить ключи, так как по ключу с помощью хэш-функции вычисляется значение указателя на значение. Однако, ключи возвращаются при обходе с помощью `range`, а также ключи необходимо хранить в случае возникновения коллизий, а значит, ключи в мапе всё же хранятся.

Хэш-таблица является ссылочным типом, по умолчанию nil, поэтому перед использованием требуется вызов `make()`  или инициализация литералом (типовая ошибка).

Доступ по ключу хэш-таблицы может возвращать одно либо два значения. Во второй случае возвращается само значение и булевый флаг, сигнализирующий о наличии элемента в мапе.
```go
value, exists := myMap[k]
if !exists {...}
```

Добавление в nil-овую мапу вызовет панику, а получение значения из nil'овой мапы не вызовет панику:

```go
package main  
  
func main() {  
    var a map[int]bool  
    _ = a[1]  
    // no panic  
}
```

```go
package main  
  
func main() {  
    var a map[int]bool  
    a[1] = true // panic: assignment to entry in nil map
}
```

<h5>Устройство хэш-таблицы</h5>
Хэш-таблица состоит из нескольких компонентов:
1. Набор ключей
2. Хэш-функция, которая по ключам возвращает число фиксированной длины
3. Массив (реальный массив, array) указателей на значения, в котором хранятся указатели на значения, которые мы храним
4. Набор значений

Таким образом, хэш-функция и массив указателей на значения позволяют сопоставить набор ключей и набор значений.

Хэш-функция для каждого ключа (какой бы он ни был, число или длинная строка) вычисляет целое число, которое является индексом массива указателей. Используется остаток от деления целого числа на кол-во элементов массива.

Для доступа к значению по ключу вычисляется хэш-функция и используется указатель из вычисленного номера ячейки (доступ к элементу массива за О(1)).

Коллизии возникают, если несколько значений попали в одну ячейку. Для хранения нескольких значений в одной ячейке, ячейка представляется в виде **связного списка**, содержащего пары "ключ-значение".

Применение хэш-таблицы:
- справочники, словари
- как множество — подсчёт уникальных элементов
- многое другое

**Коллизии**. Поскольку массив указателей имеет ограниченный размер, то время от времени будет возникать коллизия: хэш-функция будет указывать на занятую ячейку (используется деление по модулю, равному количеству ячеек массива).
Ячейке массива указателей может быть сопоставлен связный список с дополнительными значениями.
___
<h5>Связный список</h5>
Связный список (List) — структура данных, состоящая из элементов, содержащих помимо собственных данных ссылки на следующий и(или) предыдущий элемент.
Если хранится только одна ссылка (на следующий или предыдущий элемент) — односвязный список.
Если хранятся две ссылки, на следующий и предыдущий элемент — двусвязный список.

Свойства:
- Доступ к произвольному элементу за О(n)
- Удаление и вставка за О(1) при условии нахождения курсора в месте операции
- Существенное преимущество перед массивами: минимальный расход памяти при изменении (при добавлении элемента, не нужно аллоцировать новую область памяти, равную объёму уже имеющегося списка)

**Где применяются списки?**
- Различные компоненты системного ПО (компиляторы, СУБД и т.д.)
- Кэш данных (в кэше необходимо удалять и добавлять данные, а эти операции эффективны в списках)
- Другие структуры данных (очереди, стеки) могут быть легко реализованы на базе списка
- **Списки используются в хэш-таблицах для разрешения коллизий**
- Списки очень часто спрашивают на собеседования :))
- Изначально списки использовались как альтернатива массивам из-за жёстких ограничений памяти компьютера
- Применение: хранение небольшого количества больших объектов
___
<h5>Бинарное дерево поиска</h5>
Это иерархическая структура данных, в которой каждый узел имеет не более двух потомков, для которого выполняются следующие дополнительные условия (свойства дерева поиска):
- Оба поддерева — левое и правое — являются двоичными деревьями поиска
- У всех узлов левого поддерева произвольного узла X значения ключей данных меньше либо равны X
- У всех узлов правого поддерева произвольного узла X значения ключей данных больше либо равны X

![[Pasted image 20240706184041.png]]

Алгоритм поиска по дереву: если искомое значение меньше вершины, исследуем левое поддерево, если больше, исследуем правое, если равен — результат получен.

Средний случай для поиска: $O(\log n)$
Худший случай для поиска: $O(n)$
___
<h5>Стек</h5>
Стек — структура данных, в которой извлечение данных осуществляется в порядке LIFO.

Операции вставки и извлечения данных для стеков называются `push` (запись) и `pop` (снятие со стека).

Примером стека является стек вызовов функций, где каждая новая вызываемая функция помещает наверх стека адрес возврата. Таким образом, последняя вызванная функция завершается первой.
___
<h5>Очередь</h5>
Очередь — структура данных, в которой извлечение данных осуществляется в порядке FIFO.

Операции вставки и извлечения данных из очередей называются `enqueue` и `dequeue`. Примеры очереди в Go — каналы.

🚨 Очереди сообщений (Rabbit, Kafka) не всегда ведут себя как очереди. 

Стеки и очереди можно реализовать посредством массивов или связных списков.
___
<h5>Куча</h5>
Изучать самостоятельно...
(ум ваче сэээй)