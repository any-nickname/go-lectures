План занятия:
- Понятие и задачи тестирования
- Виды тестов. Пирамида тестирования
- Тестирование в Go
- Модульные тесты
- Тестирование зависимостей
- Тестирование дерева пакетов
- Интеграционные тесты
- Тестирование HTTP-обработчиков
- Test-Driven Development (TDD)
- Бенчмарки (тесты производительности)

Тестирование — это очень важно и очень нужно. Многие бекэнд программисты не умеют писать программисты, к сожалению?

Написание хороших тестов — тренируемый навык.
___
<h5>Понятие и задачи тестирования</h5>
**Тестирование ПО** — процесс испытания программного кода на специально подготовленных данных для определения соответствия реального и ожидаемого поведения программы.

Тестовые данные могут быть как заранее определённые, так и случайные.
Тесты — **простой программный код**, вызывающий тестируемый код и анализирующий результат.

> **Если ваши тесты сложные — то они плохие!** Сложные тесты тоже придётся тестировать. 

Тестирование позволяет определить соответствие ПО требованиям.
Тестирование предназначено для повышения качества ПО и нахождения ошибок в коде программы.
Тестирование упрощает развитие и сопровождение ПО (поддержка переработки кода).

<h6>Когда пишутся тесты?</h6>
Тесты пишутся до, вместе с или после написания тестируемого кода.

Заранее подготовленные тестовые данные иногда называют фикстурами (fixtures)

**Процент покрытия кода** — доля кода в процентах, который был исполнен в результате выполнения тестов, по отношению к общему количеству кода. Покрытие 0% и 100% обычно является нежелательным.
Покрытие измеряется на уровне пакета.

> Почему 100% покрытия кода тестами обычно плохо?

Сложно достичь 100% покрытия кода, при этом не факт, что абсолютно весь код необходимо тестировать, например, внешние вызовы. Некоторый код тестировать вообще не нужно. Нужно понимать, какой код стоит тестировать — руководствуйся разумом и опытом.

Как правило, тест состоит из:
- Набор тест-кейсов (входных данных)
- Вызов тестируемого кода (функции)
- Сравнение результата работы функции с заранее вычисленным правильным значением

<h6>О именовании функций для тестов</h6>
Тест всегда имеет одну и ту же сигнатуру: `TestFuncName(t *testing.T)`
Если тестируемая функция экспортируемая, то нейминг `TestFuncName`. Если тестируемая функция неэкспортируемая, то нейминг `Test_funcName`.
Если мы тестируем метод типа данных, то в названии также должно фигурировать имя типа данных, например `TestService_Products` (тип данных `Service`, метод `Products`).

Пример простого теста:
```go
package simple  
  
func sum(a, b int) int {  
    return a + b  
}
```

```go
package simple  
  
import "testing"  
  
func Test_sum(t *testing.T) {  
    type args struct {  
       a int  
       b int  
    }  
    tests := []struct {  
       name string  
       args args  
       want int  
    }{  
       {  
          "3+5=8",  
          args{3, 5},  
          8,  
       },  
    }  
    for _, tt := range tests {  
       t.Run(tt.name, func(t *testing.T) {  
          if got := sum(tt.args.a, tt.args.b); got != tt.want {  
             t.Errorf("sum() = %v, want %v", got, tt.want)  
          }  
       })  
    }  
}
```

В Go принято называть переменную с заранее вычисленным результатом: `want`, а переменную с полученным результатом: `got`.
___
<h5>Виды тестов. Пирамида тестирования</h5>
Тесты бывают разные и делятся по следующим признакам:
- Автоматизированные (это наш случай) и ручные
- Нагрузочные тесты (проверяют поведение кода под нагрузкой) и тесты логики (проверяют логику)
- По доступу к коду ПО: белый (внутренние для системы тесты) и чёрный ящик (внешние по отношению к системе)
- По уровням тестирования:
	- Модульные
	- Интеграционные
	- Компонентные
	- Приёмочные (end-to-end, функциональные)

Разработчики создают автоматизированные модульные и интеграционные тесты.
Функциональные тесты и ручное тестирование — задачи тестировщиков.
<h6>Пирамида тестирования</h6>
![[Pasted image 20240707212215.png]]

Чем ниже уровень пирамиды, тем:
- проще тесты
- больше тестов данного уровня в системе
- выше степень автоматизации

Модульные тесты (юнит-тесты) тестируют отдельные модули. 
**Модуль — минимальный функциональный блок кода**, в Go это функция.
Модульные тесты, как правило, запускаются автоматически при сборке приложения.

Интеграционные тесты тестируют интеграцию компонентов. Компонентами могут выступать как отдельные компоненты нашей системы, так и интеграция наших компонентов с внешними компонентами, например код, работающий с БД или брокерами сообщений.
**Такие тесты тестируют нашу интеграцию с чем-то.**

Функциональные тесты (end-to-end тесты) тестируют целые функции с точки зрения бизнес-логики. Например, тестирование добавления покупки в корзину в интернет-магазине.
Этот тест проверяет целое бизнес-требование, имитирует поведение пользователя.
Функциональные тесты, как правило, инициируются вручную.
___
<h5>Тестирование в Go</h5>
В Go существует фреймворк (пакет) для тестирования "testing", идущий вместе со стандартной библиотекой.
https://pkg.go.dev/testing

Тесты размещаются в файлах пакета с именем `*_test.go`. При компиляции, Go игнорирует такие файлы. Соответственно, глобальные переменные в тестовых файлах не будут доступны в других файлах программы.

Для запуска тестов используется команда `go test путь`
Основные флаги команды:
- "-v" - вывод сообщений для каждого теста
- "-cover" - вывод процента покрытия кода
- "-run имя_теста" - запуск конкретного теста
\
Пример запуска:
`go test -v -cover -run Test_sum`

При повторном запуске теста, если код не изменился, результат берётся из кеша.

> To disable test caching, use any test flag or argument other than the cacheable flags. The **idiomatic way** to disable test caching explicitly is to use **-count=1**.

Тест может быть разделён на подтесты для запуска на наборе примеров, используя:
`func (t *T) Run(name string, f func(t *T)) bool`

Тесты можно запускать параллельно, используя:
`func (t *T) Parallel()`

Пакет `testing` позволяет:
- Фиксировать неудачу (`Error()`, `Fatal()` и др.)
- Выводить сообщения (`Log()`, `Logf()`)
- Пропускать тесты (`Skip()`, `SkipNow()`)

<h6>Предварительная инициализация</h6>
Иногда для тестирования нам необходимо предварительно инициализировать какой-либо объект. Делать это в каждом очередном тесте неудобно.
Чтобы инициализировать предварительные условия перед тестированием, мы можем использовать функцию `TestMain (m *testing.M)`. Если такая функция есть в тестовом пакете, она выполняется при каждом запуске тестирования, один раз перед запуском всех тестов.

Например, это может быть полезно для интеграционного тестирования функций, взаимодействующих с базой данных. В функции `TestMain` можно осуществить подключение к БД.

<h6>Табличные тесты</h6>
Для выполнения теста на нескольких наборах входных данных используются табличные тесты. Такие тесты автоматически генерируют IDE VS Code и GoLand.

Функция:
```go
package table  
  
func reverse(s string) string {  
    r := []rune(s)  
  
    for i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {  
       r[i], r[j] = r[j], r[i]  
    }  
  
    return string(r)  
}
```

Табличный тест:
```go
package table  
  
import "testing"  
  
func Test_reverse(t *testing.T) {  
    type args struct {  
       s string  
    }  
    tests := []struct {  
       name string  
       args args  
       want string  
    }{  
       {  
          "Test1",  
          args{"apple"},  
          "elppa",  
       },  
       {  
          "Test3",  
          args{"меч"},  
          "чем",  
       },  
    }  
    for _, tt := range tests {  
       t.Run(tt.name, func(t *testing.T) {  
          if got := reverse(tt.args.s); got != tt.want {  
             t.Errorf("reverse() = %v, want %v", got, tt.want)  
          }  
       })  
    }  
}
```

Тестовые примеры размещаются в массиве `tests := []struct { }`
Каждому примеру желательно давать имя. Каждый пример запускается в подтесте: `t.Run(...)`. Для создания шаблона табличных тестов следует использовать возможности IDE.

Тестовые примеры лучше подбирать так, чтобы проверить краевые случаи и разную логику работы.
___
<h5>Модульные тесты</h5>
Модульные тесты (unit tests) — тесты минимальных самостоятельных единиц кода (в Go - функция).
Цель модульного тестирования — проверить работоспособность частей программы по отдельности и выявлять регрессию (ошибки в уже оттестированном работоспособном коде) при развитии или переработке кодовой базы.

Модульные тесты зачастую выполняются при сборке программного продукта.

Модульные тесты не должны иметь внешних зависимостей: БД, сеть, файлы и т.д. Вместо них необходимо использовать моки.

Модульные тесты в Go — очень быстрые.

Модульные тесты составляют подавляющее большинство от всех тестов. В среднем считается, что хорошим процентом покрытия кодовой базы является 70% и выше, однако это зависит от характера кода.

Модульные тесты не стоит использовать для тестирования тривиального кода(взять JSON и переложить в другое место - тестировать сомнительно).

Если некоторый код вызывается функцией, для которой написан подробный тест, то писать тест для этого кода не надо.
Также не стоит писать тесты для чужого кода (например, стандартной библиотеки или же если в своём коде мы вызываем чужую функцию).

Не нужно дублировать тесты. Например, у нас есть функция, которую мы декомпозировали на несколько более простых, и написали тесты для этих маленьких функций. Тогда, скорее всего, не имеет смысла писать тест для большой функции, объединяющей протестированные маленькие. Незачем несколько раз тестировать один и тот же код.

Модульные тесты не должны затруднять развитие кодовой базы = их не должно быть слишком много.

> [!NOTE] Слово о тестах
> Тесты должны вам помогать, а не мешать. Причём они должны помогать не когда-нибудь, а прямо здесь и сейчас.

Но для того, чтобы тесты начали помогать, их нужно научиться писать ^.^
___
<h5>Тестирование зависимостей</h5>
Под зависимостью при тестировании подразумевают любой внешний объект, который может быть недоступен в тестовой среде.

Типовые зависимости:
- База данных
- Сетевой ресурс
- Файл

Почему это зависимости, внешний объект? Наши тесты могут запускаться в такой среде, где не будет доступа к БД или сети. Код, использующий внешние зависимости, создаёт проблему — мы не можем гарантировать, что этот код может быть протестирован в любой тестовой среде.

Для тестирования кода, имеющего внешние зависимости, используют программную имитацию (mock, stub, заглушка) таких зависимостей. Другими словами, мы можем создать простые объекты, доступные в коде и имитирующие внешние зависимости.
Например, БД в памяти, создаваемая при старте тестов.
<h6>Разница между mock и stub?</h6>
Считается, что stub это просто тупорылая заглушка, а mock — некая имитация, при которой действительно создаётся какая-то функциональная тривиальная подмена для тестируемой зависимости (например, функции записи бы писали что-то в хранилище, а функции чтения возвращали изменённое состояние). В свою очередь, stub была бы простой заглушкой, не делающей ничего.

Выходит, mock слегка более интеллектуальная сущность, чем stub.
<h6>Как тестировать код, вызывающий зависимости?</h6>
Для того, чтобы можно было протестировать код, вызывающий зависимости, этот код должен использовать абстракцию — интерфейс.

Если функция принимает интерфейс в качестве аргумента, то в рабочем коде мы можем передать реальную реализацию интерфейса, а в тесте — имитацию (заглушку).

Для этого реальный объект и заглушка должны быть некоторыми типами данных, выполняющими контракт интерфейса, используемого в тестируемой функции.
<h6>Переработка кода с зависимостями</h6>
Не всегда существует возможность имитировать зависимости. В этом случае протестировать код, использующий зависимость, может быть невозможно — тогда используется стандартный приём рефакторинга, 
"**выделение функции**":
- Из функции, содержащей вызов зависимости и тестируемую бизнес-логику, выделяется функция, содержащая только бизнес-логику,
- Для функции с бизнес-логикой пишется тест,
- Функция с вызовом зависимостей не тестируется.

*Fun Fact:* существует и обратный метод рефакторинга, "**встраивание функции**", в ходе которого избавляются от однострочных функций, логику которых удобнее разместить в месте вызова.
___
<h5>Интеграционные тесты</h5>
В модульных тестах, внешние зависимости нам мешают. В интеграционных тестах мы, наоборот, фокусируемся на тестировании внешних зависимостей.

**Интеграционные тесты** — тестирование взаимодействия компонентов системы.
Под интеграционными тестами также понимают **тестирование взаимодействия с внешними системами**:
- базы данных
- журналы, мониторинг
- API внешних систем - платёжные системы, партнёры и т.д.

Интеграционные тесты требуют наличия реальных зависимостей, хотя они, как правило, и представлены тестовыми экземплярами, например тестовые базы данных, тестовые серверы и т.д.

Данные, используемые во внешних зависимостях, должны быть похожи на реальные. 

Например, тестовая БД должна содержать набор данных, приближенный к реальному.
Создать такую БД можно разными способами:
- Выполнить запрос на имеющемся сервере СУБД;
- Запустить контейнер с инициализацией БД при создании;
- Использовать образ виртуальной машины.

**Тесты БД должны быть идемпотентны** — многократный вызов одного и того же теста должен давать одинаковый результат. Поэтому, по возможности, следует очищать созданные записи.

Например, тестовый сервер должен имитировать поведение реального сервера. Должен использоваться реальный протокол взаимодействия и реальная модель данных.

Поскольку успех тестирования в этом случае зависит от внешнего поставщика, то такие тесты должны запускаться при определённых условиях — например, при указании флага командной строки, сигнализирующем о том, что внешняя среда готова к тестам.
Ещё одна причина для запуска интеграционных тестов не по умолчанию, а только при включении флага в том, что интеграционные тесты медленнее модульных (вызовы к внешним API наиболее тяжёлые), и мы можем хотеть их запускать не всегда.
___
<h5>Тестирование HTTP-обработчиков</h5>
HTTP-обработчик (http handler) — функция, отвечающая за обработку HTTP-запроса для метода API.

Для тестирования используется пакет "**httptest**" (ещё один и последний пакет из стандартной библиотеки для тестирования в Go).

Тест предполагает создание объекта запроса, объекта для записи ответа и вызов обработчика. Необходимо самому позаботиться об имитации внешних зависимостей.

Обработчик:
```go
func (api *API) ProductsHandler(w http.ResponseWriter, r *http.Request) {
	data := []product{
		{
			Name: "Книга",
			Price: 1000,
		}
	}
	
	err := json.NewEncoder(w).Encode(data)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
}
```

Тест:
```go
func TestAPI_ProductsHandler(t *testing.T) {
	req := httptest.NewRequest(http.MethodGet, "/api/HANDLER", nil)
	rr := httptest.NewRecorder()

	api.ProductsHandler(rr, req)

	if !(rr.Code == http.StatusOK) {
		t.Errorf("код неверен: получили %d, а хотели %d", rr.Code, http.StatusOk)
	}
	resp := rr.Result()
	body, _ := io.ReadAll(resp.Body)
	var data []product
	json.Unmarshal(body, &data)
	t.Logf("Ответ сервера: \n%v\n", data)
}
```
___
<h5>Test-Driven Development (TDD)</h5>
Test-Driven Development — методология разработки, относящаяся к "экстремальному программированию".

Суть методологии в написании теста до написания тестируемого кода.
<h6>Red. 🔴 Green. 🟢 Refactor. 🔵</h6>
TDD описывается циклом действий, направленных на решение задачи:
1. Написание простого теста, проверяющего результат работы задачи (**RED** 🔴)
2. Написание минимального кода, удовлетворяющего тесту (**GREEN** 🟢)
3. Переработка теста для более точного соответствие требованиям задачи (**REFACTOR** 🔵)
4. Переход на шаг 1

Как можно видеть, эта методология итерационная.
TDD является хорошим выбором, когда алгоритм решения задачи и конечный результат известны заранее.
TDD следует применять с осторожностью, как и любую другую строгую методику, а именно — учитывать характер задач и иных требований.

https://quii.gitbook.io/learn-go-with-tests/
___
<h5>Бенчмарки в Go</h5>
Бенчмарки нужны для тестирования производительности.

Замеры (тесты) производительности (benchmarking) —измерение усреднённых значений времени выполнения и потребления ресурсов в результате многократного запуска тестируемого блока кода.

Замеры производительности схожи с модульными (unit-) тестами, ибо они так же выполняются для отдельных функций.

<h6>Цель замеров производительности — сравнить различные реализации алгоритмов между собой для определения более эффективного.</h6>

Тесты производительности не запускаются вместе с автоматическими тестами по умолчанию. Для запуска бенчмарков используется команда:
`go test -bench . -v`
Эта команда также запустит и все тесты. Если этого не требуется, то можно указать запуск несуществующего теста:
`go test -bench . -v -run XXX` ("-run XXX" отвечает за запуск несуществующего теста)

Для вывода информации по использованной памяти нужно добавить флаг `-benchmem`:
`go test -bench . -v -run XXX -benchmem`

Справка по флагам тестирования и замерам производительности:
`go help testflag`

```go
func BenchmarkBinary(b *testing.B) {
	data := sampleData()
	for i := 0; i < b.N; i++ {
		n := rand.Intn(1000)
		res := Binary(data, n)
		_ = res
	}
}
```

Число `b.N` Go вычисляется без нашего участия, автоматически. Нейминг аналогичен модульным тестам, но вместо "Test" мы пишем "Benchmark".

Литература:
- https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go
- https://pkg.go.dev/testing

> "Я надеюсь, что тесты вы будете писать постоянно. Они очень упрощают нашу работу. Это важное и нужное дело, однако ему необходимо обучиться".