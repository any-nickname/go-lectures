План занятия:
- Понятие и виды алгоритмов
- Простой и бинарный поиск
- Сложность алгоритма. О-нотация
- Алгоритмы сортировки
- Рекурсия, стек вызовов
- "Разделяй и властвуй", динамическое программирование, жадные алгоритмы
- Алгоритмы на графах
- Алгоритмы в стандартной библиотеке
___
<h5>Понятие алгоритма</h5>
**Это практические вещи**, даже если что-то кажется просто академическими знаниями. Алгоритмы, следовательно вопросы производительности, играют важную роль как в крупных, так и в маленьких системах.

Алгоритм — набор инструкций (шагов) для решения некоторой задачи.
Алгоритм не про время или про затраты электроэнергии, а про шаги.
Алгоритм должен обладать следующими свойствами:
- дискретность (конечный набор простых шагов)
- детерминированность (последовательность шагов чётко определена)
- универсальность (применимость к различным наборам данных)
- результативность (завершение алгоритма результатом)
___
<h5>Простой и бинарный поиск</h5>
Простой поиск: перебираем все элементы массива в поисках нужного элемента и возвращаем его индекс, в противном случае -1.

Бинарный поиск: имеем отсортированный массив, в цикле делим массив пополам; если искомый элемент меньше того, что в середине, то в новой итерации смотрим левую половину массива; если искомый элемент больше того, что в середине, то в новой итерации смотрим правую половину массива; если элемент в середине - возвращаем индекс.

Бывает целочисленный бинарный поиск и бинарный поиск на "continuous" пространстве.
___
<h5>Сложность алгоритма. О-нотация</h5>
Под сложностью (производительностью) алгоритма понимают оценку количества **шагов**, требующихся для решения задачи.

Поскольку алгоритмы применяются к выборке данных, то количество шагов выражается функцией от количества элементов в выборке.
Для обозначения оценки сложности используют нотацию "О большое". Например: О(1), О(log n), O(n), O(n$^2$), O(n!) и другие.

О-нотация показывает максимальное число требуемых шагов (худший случай). Сложность алгоритма рассчитывается по наиболее "тяжёлому" месту программы. То есть по участку, в котором программа выполняет наибольшее количество операций (шагов).

Простой поиск в худшем случае проходит все элементы массива, значит его сложность O(n).

Бинарный поиск делит массив пополам на каждом этапе, значит его сложность пропорциональна логарифму по основанию 2, O(log n).

> [!NOTE] Fun Fact
> Задача коммивояжёра имеет оценку O(n!)

Для О-нотации вводят понятие лучшего, среднего и худшего случая.
В О-нотации не учитываются константы $O(1000000.37 * n)=O(n)$.
___
<h5>Алгоритмы сортировки</h5>
Примеры реализации алгоритмов сортировки:
http://www.rosettacode.org/wiki/Category:Sorting_Algorithms

Современные алгоритмы сортировки:
- пирамидальная сортировка (heapsort)
- сортировка слиянием (mergesort)
- быстрая сортировка(quicksort)
- сортировка распределением (distribution sort)

Лучшие алгоритмы сортировки имеют сложность $O(n*\log n)$

Быстрая сортировка — наиболее популярный алгоритм, в худшем случае имеет сложность $O(n^2)$. В среднем её сложность: $O(n*\log n)$.

Что же лучше — отсортировать массив и использовать бинарный поиск, или использовать простой поиск?
Сортировка + бинарный поиск = $O(n * \log n + \log n) = O(n * \log n)$
Простой поиск = $O(n)$
кажется, что простой поиск эффективнее, так как $n < n * \log n$
___
<h5>Задачи, решаемые алгоритмами сортировки</h5>
**Поиск**. При условии, что входные данные отсортированы, двоичный поиск элемента в занимает время $O(\log n)$.
**Определение уникальности элементов.** После сортировки одинаковые элементы будут располагаться вместе.
**Выбор элемента.** В отсортированном массиве k-й по величине элемент можно найти за константное время.

Сама по себе сортировка может быть не нужной, но она является базой для многих других задач.
___
<h5>Рекурсия</h5>
Рекурсия — способ решения задачи, заключающийся в разделении задачи на более мелкие. При этом для решения задачи используется функция, которая вызывает сама себя.

Рекурсивная функция состоит из двух частей:
- Базовый случай
- Шаг рекурсии
Базовый случай предназначен для предотвращения бесконечного цикла.

Рекурсивный алгоритм возведения в степень:
```go
package main

import (
	"fmt"
)

// pow рекурсивно возводит x в степень y.
func pow(x, y int) int {
	if y == 0 { // Базовый случай.
		return 1
	}
	return x * pow(x, y-1) // Рекурсивный шаг.
}

func main() {
	fmt.Println("3^2:", pow(3, 2))
	fmt.Println("5^3:", pow(5, 3))
}
```
<h5>Стек вызовов</h5>
**Стек вызовов** (call stack, стек) — LIFO-стек, хранящий информацию для возврата управления из подпрограмм (процедур, функций) в подпрограмму, при вложенных или рекурсивных вызовах (Википедия).

Стек — область памяти, в которую заносятся адреса возврата в вызывающую функцию.

Размер стека вызовов в Go лимитирован 1 гигабайтом (миллиард байт). Если убрать базовую часть из примера с рекурсией, то получится stack overlfow:
`runtime: goroutine stack exceeds 1000000000-byte limit`
`runtime: sp=0xc0=20161380 stack=[0xc020160000, 0xc040160000]`
`fatal error: stack overflow`

При вызове вложенной функции, мы должны сохранить контекст внешней функции, чтобы, когда мы вернёмся из вложенной функции, состояние программы сохранилось. Контекст функции сохраняется в стеке вызовов **(?)**
Последняя вызванная функция завершается первой, далее мы возвращаемся в вызвавшую её функцию, спускаясь по стеку всё ниже и ниже.


**Цикл vs Рекурсия.**
Рекурсия является довольно медленной, так как адресный переход (смена контекста) является затратной операцией. Поэтому, как правило, циклические алгоритмы работают быстрее и не подвержены ошибке stack overflow, однако иногда рекурсивные алгоритмы проще.
___
<h5>"Разделяй и властвуй", динамическое программирование, жадные алгоритмы</h5>
**D&C** — разделяй и властвуй, техника разработки рекурсивных алгоритмов. Задача разбивается на части, таким образом, что решение части задачи существенно проще, чем решение всей. Такое разбиение может быть циклическим (повторяться многократно).

Например, задача рекурсивно разбивается на половинки, каждая половина решается по отдельности, после решения каждой половины, их решения объединяются.

**Эффективный алгоритм** получается в случае, когда слияние решений половин занимает меньше времени, чем их решение.

Примеры D&C:
- mergesort
- quicksort

**Динамическое программирование** — техника, когда задача раскладывается на последовательность подзадач. Первый элемент последовательности имеет тривиальное решение. Последний элемент последовательности — исходная задача.
Каждая задача этой последовательности может быть решена с использованием решения подзадач с меньшими номерами.

В динамическом программировании используется **мемоизация** вычислений. Например, следующий элемент в последовательности связан с одним или несколькими предыдущими. Ранее мы посчитали и закешировали эти предыдущие элементы последовательности, таким образом наши вычисления ускоряются.

**Жадные алгоритмы** — алгоритмы, которые на каждом шаге принимают локально-оптимальное решение. При этом результат работы может быть глобально не оптимальным. 

Вспоминаешь задачу о том, чтобы набрать определённую сумму монетками разных номиналов? :) При жадном решении просто берётся наибольший номинал, когда он станет оверхедом, берётся более меньший и т.д. Жадно эту задачу не решить.

Жадные алгоритмы жертвуют точностью ради скорости.

Жадные алгоритмы используются там, где точные вычисления крайне трудоёмки или принципиально невозможны (NP-полные задачи). Либо там, где не требуется точного решения, а достаточно хорошего и быстрого.

Примеры задач:
- Задача коммивояжёра
- Задача о покрытии множества
___
<h5>Алгоритмы в стандартной библиотеке</h5>
Стандартная библиотека не предоставляет широкого выбора алгоритмов, если что-то необходимо, можно найти на гитхабе.

Стандартная библиотека предоставляет пакет `sort`: https://pkg.go.dev/sort

Для того, чтобы сортировать данные с помощью этого пакета, сортируемый тип должен удовлетворять интерфейсу `Interface` (че за странное название...)
```go
type Interface interface {
	Len() int
	Less(i, j int) bool
	Swap (i, j int)
}
```

Это единственная сортировка из стандартной библиотеки.

На базе этой сортировки реализована дополнительная функция `Slice`, которая принимает на вход произвольный слайс с объектами и функцию-компаратор `less func(i, j int) bool`.

В стандартной библиотеке также есть функция бинарного поиска `Search`.