План занятия:
- Понятие и устройство интерфейса
- Пустой интерфейс
- Проверка типа интерфейса
- Важные интерфейсы
- Обобщённое программирование (Generics)
___
<h5>Понятие и устройство интерфейса</h5>
**Интерфейсные типы выражают обобщение или абстракцию поведения других типов** (Алан Донован).

Альтернативное определение: **интерфейс — это именованный набор сигнатур методов (контракт интерфейса)**.

Итого, интерфейс — это тип данных. Интерфейсный тип — это абстрактный тип данных, который определяет набор методов, которыми должен обладать конкретный тип, чтобы считаться экземпляром интерфейса.

Интерфейсы предназначены для придания нашему ПО гибкости в реализации и позволяют писать полиморфический (обобщённый) код.

В Go имеет место утиная типизация, подразумевающая, что интерфейсы выполняются неявно. Если наш тип данных реализовал контракт какого-либо интерфейса, то он автоматически стал удовлетворять этому интерфейсу, а мы можем даже этого не узнать.

Любой тип данных может реализовать контракт интерфейса.

> [!NOTE] Слово об интерфейсе
> The bigger interface — the weaker abstraction

У хорошего интерфейса должно быть небольшое количество методов, и чем меньше в интерфейсе методов, тем более абстрактным он является, так как ему могут удовлетворить больше сущностей.

https://golang.org/ref/spec#Interface_types
Интерфейс — структура, описанная в пакете "runtime" (https://pkg.go.dev/runtime)
Интерфейс — неэкспортируемая структура. Файл "runtime2.go":
```go
type iface struct {
	tab *itab           // указатель на таблицу с типом значения и его методами
	data unsafe.Pointer // указатель на конкретное значение
}
```

Переменная интерфейсного типа является экземпляром структуры `iface` и по умолчанию в качестве значений обоих полей содержит `nil`.

После присвоения интерфейсу некоторого значения:
- поле `tab` будет ссылаться на таблицу, в которой содержится тип значения и полный список его методов с типом получателя;
- поле `data` будет ссылаться на само присвоенное значение.

Интерфейс это ссылочный тип данных, представляющий из себя структуру, следовательно, его значением по умолчанию является nil.
___
<h5>Хитрость пустого интерфейса (вопрос на собес)</h5>

___
<h5>Почему нельзя передать адрес на константу в Go?</h5>
Почему нельзя сделать так:
```go
const a = "mystring"
p := &a
```

и так:
```go
p := &"mystring"
```

, а!?

Константы в Go оптимизированы! Это значит, что одна и та же константа, написанная в коде, будет храниться по одному и тому же адресу, являясь одним и тем же объектом:
```go
const (
	a = 10
	b = 10
	c = 10
)
```

Здесь, у трёх переменных a, b и c будет один и тот же адрес.

Оптимизация констант выполнена для оптимизации потребления памяти приложением, что выглядит как хорошая и логичная идея - если мы используем одно и то же неизменное значение в разных местах, почему бы не сохранить его в памяти лишь однажды?
___
<h5>Пустой интерфейс</h5>
> Бытует мнение, что интерфейсы в Go это вторая по сложности тема, после конкурентного программирования.
> Некоторые считают, что интерфейсы в Go перегружены в смысловом плане:
> 	С одной стороны, интерфейсы необходимы для реализации полиморфического поведения и служит для моделирования нашей системы (механизм, с помощью которого функция может работать с данными разных типов, называется полиморфизмом).
> 	С другой стороны, существует пустой интерфейс, который служит совершенно иным целям, представляя контейнер для произвольного типа данных.

Пустой интерфейс был предложен авторами языка для использования в качестве контейнеров для любого типа (любой тип данных удовлетворяет пустому интерфейсу).
<h6>Теория</h6>
Пустой интерфейс — интерфейс, имеющий пустой контракт, и служащий контейнером для любого типа данных.
Пустой интерфейс используется в утилитах, работающих с данными произвольного типа:
- форматированный вывод (fmt, log)
- кодирование и декодирование (json, xml, gob)
- сортировка (sort)
- и т.д.

В Go 1.18 для пустого интерфейса появился алиас `any`, который эквивалентен `interface{}` во всех смыслах.
___
<h5>Type cast</h5>
Или же проверка типа интерфейса. Операция используется, например, когда функция получила на вход переменную типа интерфейса, а нам хочется узнать конкретный тип этой переменной. В этом случае мы можем попытаться скастовать переменную к другому типу. Для этого используется операция:
\
`x.(T)`

здесь `x` — интерфейс, `T` — некоторый тип данных.
Данная операция извлекает и возвращает значение конкретного типа из интерфейса.

Операция проверки (подтверждения) типа используется для преобразования переменной интерфейсного типа в переменную конкретного типа.

Если проверяемым типом является интерфейс, то операция проверяет, удовлетворяет ли текущее значение интерфейса контракту проверяемого интерфейсного типа. 
Если удовлетворяет, то тип данных интерфейса меняется (обычно таким образом происходит расширение набора методов).
```go
package main  
  
import "fmt"  
  
type sender interface {  
    send(msg string)  
}  
  
type receiver interface {  
    receive()  
}  
  
type radio struct {  
    channel int  
}  
  
func (r radio) send(msg string) {  
    fmt.Printf("'%v' was sent\n", msg)  
}  
  
func (r radio) receive() {  
    fmt.Printf("msg from channel %v was received\n", r.channel)  
}  
  
func main() {  
    msg := "Alpha 1-1, do you copy?"  
    var s sender  
    var r radio = radio{channel: 1}  
  
    fmt.Println("1.")  
    s = r  
    s.send(msg)  
  
    fmt.Println("2.")  
    // Знакомьтес, type switch.
    // Подойдут оба кейса, но первый выполнится раньше.  
    switch r1 := s.(type) {  
    case radio:  
       r1.channel = 23  
       r1.receive()  
    case receiver:  
       r1.receive()  
    }  
  
    // Хотя мы приводим тип sender к типу receiver,  
    // исходный объект это тип radio, у которого    
    // есть собственная реализация, которая и    
    // используется при вызове метода `receive`.    
    fmt.Println("3.")  
    if r1, ok := s.(receiver); ok {  
       r1.receive()  
    }  
  
    fmt.Println("4.")  
    if r2, ok := s.(radio); ok {  
       newMsg := "Overlord, we copy, go ahead"  
       r2.send(newMsg)  
       r2.receive()  
    }  
  
    // Таким образом, при касте к более узкому типу,  
    // исходный тип не теряется безвозвратно, он может    
    // быть восстановлен с тем же состоянием (в наших    
    // примерах, исходных channel = 1 сохранился при    
    // касте radio к sender).}
```

P.S. Мы непосредственно не конвертируем один тип во второй, заменяя исходный, а создаём новую переменную второй типа, извлекая значение из переменной первого типа!!!
___
<h5>Важные интерфейсы</h5>
```go
// bultin
type error interface {
	Error() string
}

// io
type Reader interface {
	Read(p []byte) (n int, err error)
}

// io
type Writer interface {
	Write(p []byte) (n int, err error)
}

// sort
type Interface interface {
	Len() int
	Less(i, j int) bool
	Swap(i, j int)
}

// fmt
type Stringer interface{
	String() string
}

// net
type Conn interface {
	Read( b []byte) (n int, err error)
	Write(b []byte) (n int, err error)
	Close() error
	LocalAddr() Addr
	RemoteAddr() Addr
	SetDeadline(t time.Time) error
	SetReadDeadline(t time.Time) error
	SetWriteDeadline(t time.Time) error
}

// net
type Listener interface {
	Accept() (Conn, error)
	Close() error
	Addr() Addr
}

// net/http
type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}

// net/http
type ResponseWriter interface {
	Header() Header
	Write([]byte) (int, error)
	WriteHeader(int)
}

// encoding/json
type Marshaler interface {
	MarshalJSON() ([]byte, error)
}
```

___
<h5>Обобщённое программирование (Generics)</h5>
Это концепция.
Обобщённое программирование — возможность использовать один и тот же алгоритм для работы с данными других типов.

Поскольку Go — язык со строгой статической типизацией, то обобщённое программирование в нём было затруднено (почти невозможно) до версии 1.18.

В общем случае, для написания обобщённого алгоритма можно применять интерфейсы. Возможно использование следующих техник:
- использование методов типов данных;
- использование пустых интерфейсов.

Использование пустых интерфейсов неудобно, поскольку требует проверки типов или рефлексии. Следствие — дублирование кода, ухудшение читаемости кода.

Поэтому, в версии 1.18 была добавлена поддержка параметрического полиморфизма (generics): https://go.dev/doc/tutorial/generics

```go
package main  
  
import (  
    "fmt"  
)  
  
type ordered interface {  
    int | float64 | float32 | byte | string  
}  
  
func customMin[T ordered](a, b T) T {  
    if a < b {  
       return a  
    }  
    return b  
}  
  
func main() {  
    a, b, c := 14, 104, 52  
    res := customMin(customMin(a, b), customMin(b, c))  
    fmt.Printf(  
       "customMin (%v, %v, %v) = %v",  
       a,  
       b,  
       c,  
       res,  
    )  
}
```

Здесь мы можем увидеть третий тип интерфейса — **интерфейс-ограничение**. Интерфейс-ограничение позволяет перечислить с помощью вертикальной черты набор конкретных типов данных, которые "удовлетворяют" этому ограничению.

Типовые задачи, решаемые с помощью дженериков:
- сортировка массивов произвольных типов;
- сравнение;
- структуры данных (списки, очереди и т.д.);
- поиск минимального, максимального элемента и различная статистика.

При этом, элементы набора данных имеют один и тот же тип. Различаются типы различных наборов.

Пример пакета от авторов языка (почти стандартная библиотека):
https://pkg.go.dev/golang.org/x/exp/slices

Не стоит увлекаться дженериками, так как в более сложных структурах может быть трудно читать и понимать код, если в нём будет замешано множество обобщённых типов. При неверном применении дженериков, код может превратиться в жуть.

"Дженерики в Go: когда нужны и когда можно без них": https://habr.com/ru/companies/oleg-bunin/articles/695400/

"GopherCon 2019: Ian Lance Taylor -Generics in Go": https://www.youtube.com/watch?v=WzgLqE-3IhY&ab_channel=GopherAcademy

Чаще всего, если мы имеем дело с методами, то дженерики не требуются. Дженерики следует использовать для более простых вещей.