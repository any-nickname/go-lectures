План занятия:
- Терминология
- Методы
- Инкапсуляция и наследование
- Методы и интерфейсы
- Методы и композиция типов
- Конструкторы и деструкторы
- Использование ООП в Go
___
<h5>Терминология</h5>
>Большая часть "серьёзного", рабочего кода на Go пишется в объектно-ориентированном стиле.

Объектно-ориентированное программирование — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования (Википедия).

Можно сказать, что ООП это некий подход к моделированию предметной области с помощью классов, их экземпляров и связей, образующих иерархию. То есть, это подход к проектированию.

Общепринятого определения ООП не существует.

Введём соглашение, что ООП в Go — способ решения задачи с помощью структур данных и методов работы с этими данными.

В Go нет классов, но есть структуры, которые во многом похожи на классы.

Структура данных — любой **тип данных** (чаще всего - "struct"), это аналог класса.

Объект — **переменная любого типа данных**, имеющего методы.

Метод — **функция, связанная с некоторым типом данных.**

**ООП (в наших терминах)** — методология программирования с использованием структур, объектов и их методов.
___
<h5>Методы</h5>
Метод — это функция, содержащая аргумент-получатель (receiver).
`func (t Type) funcName(args) (values) {...}`

Получатель указывается в круглых скобках перед именем функции. Получатель состоит из имени переменной и имени типа. Объект, для которого вызван метод, доступен через получатель. Получатель может быть как значением, так и указателем.

Чаще всего методы объявляются для указателей.

Для Go, сеттеры и геттеры это нормально. При этом, для геттера используется просто имя поля, а для сеттера имя поля с префиксом set.
```go
type Course struct {
	author string
}

func (c *Course) SetAuthor(name string) {
	c.author = name
}

func (c *Course) Author() string {
	return c.author
}
```
___
<h5>Методы. Значения vs указатели</h5>
Документация: https://golang.org/doc/effective_go.html#methods

**Правило:** методы для значений могут вызываться для значений и указателей. Методы указателей — только для указателей.
**Смысл:** при вызове метода для значения, в метод передаётся копия переменной, для которой он был вызван. Поэтому все изменения переменой после выхода из метода будут утеряны.

Если метод определён для указателя, а мы вызываем его для значения, то компилятор автоматически подставит адрес, и переменная сможет быть изменена изнутри метода.

Получатель-указатель используется наиболее часто.
___
<h5>Инкапсуляция, наследование, полиморфизм</h5>
Инкапсуляция — объединение данных и методов для работы с ними в объект. При этом предполагается сокрытие данных от прямого доступа.

В Go для реализации этого шаблона мы можем использовать структуры и методы. При этом скрыть поля структур можно с помощью имён с маленькой буквы.

Наследование — возможность типа-потомка использовать данные и методы типа-родителя.

В Go такой шаблон можно условно реализовать с помощью композиции (встраивания) типов.

Полиморфический код можно писать с помощью интерфейсов.
___
<h5>Методы и интерфейсы</h5>
Тип данных может выполнить контракт интерфейса при помощи методов.

Таким образом можно использовать различные типы данных там, где программа ожидает интерфейс.

В качестве интерфейса может быть использован только тот тип переменной (указатель или значение), для которого объявлены методы.

Использование интерфейсов в качестве аргументов функции и различная реализация контрактов является основой для тестирования при помощи имитации внешних зависимостей.
___
<h5>Методы и композиция типов</h5>
Композиция (встраивание) — указание имени типа в качестве поля структуры.
Такое безымянное поле структуры имеет то же имя, что и имя типа, а также наследует все поля и методы встроенного типа.
Обращаться к полям и методам встроенного типа можно без явного указания имени встроенного типа.
Если внешний и встроенный тип содержат методы с одинаковым именем, то для выбора метода встроенного типа потребуется явно указать имя встроенного типа.
___
<h5>Конструкторы и деструкторы</h5>
В Go нет специальных конструкторов и деструкторов. Обычно для создания объекта в пакете объявляют функцию `New()`, которая возвращает указатель на объект нужного типа.

Функция `New()` должна вернуть готовый к работе объект, даже если состояние объекта необходимо загрузить из БД. Конструктор должен самостоятельно инициализировать все необходимые поля. При работе с внешними API, функция должна иметь возможность вернуть ошибку. В общем, нужно максимально облегчить работу пользователя по созданию сущности, дав ему простую и понятную функцию `New()`.

Необходимости в деструкторах в Go, на взгляд лектора, нет. За очистку неиспользуемой памяти в Go отвечает сборщик мусора, и он **очень эффективен!**
___
<h5>Использование ООП в Go</h5>
Go не загоняет разработчика в рамки одной парадигмы, предоставляя полною свободу выбора методологии.

ООП-подход стоит использовать, когда мы хотим хранить состояние и работать с ним.

Зачастую, когда мы пишем сервер, мы используем объектно-ориентированный подход, так как сервер хранит состояния: подключение к различным внешним системам, кэш, текущие сеансы пользователей и т.д. Поэтому мы моделируем сервер как объект.

Процедурное программирование с традиционными функциями стоит использовать, когда нам не нужно хранить состояние.

Функциональный стиль программирования стоит использовать, когда — лучше не использовать.

| Объектно-ориентированное программирование                                                                                                                                    | Процедурное программирование                                                                   |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- |
| Если пакет предназначен для описания некоторой сущности, которая хранит и изменяет своё состояние между вызовами методов из других пакетов, то лучше использовать ООП-стиль. | Если пакет не имеет собственного состояния, то использовать объекты и методы не рекомендуется. |
| Например, пакет для кеширования данных о наличии товаров на складе.                                                                                                          | Например, математические библиотеки.                                                           |
| Например, корзина покупок посетителя сайта.                                                                                                                                  | Например, работа со строками.                                                                  |

Зависимость — любой объект, который требуется для работы программы.

Для серверной программы зависимостями являются: БД, внешние системы, устройства, подсистемы.

Лектор предпочитает инициализировать зависимости на верхнем уровне системы - объект сервер - и передавать их при необходимости в конструкторы подсистем.