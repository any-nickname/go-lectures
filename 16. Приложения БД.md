План занятия:
- Работа с БД из Go
- `database/sql`
- Подготовленные запросы
- Транзакции
- Работа с БД напрямую
- Тестирование приложения БД
- Пакет для работы с БД
___
<h5>Работа с БД из Go</h5>
Существует два способа взаимодействия с БД из Go:
- при помощи пакета "database/sql" вместе с драйвером БД
- посредством только лишь драйвера БД

**"database/sql" + драйвер БД**
В первом случае используется пакет "database/sql", который отвечает за задачи, не связанные с манипулированием данными:
- формализация интерфейса взаимодействия с БД
- управление пулом подключений
- обработка ошибок и пр.

Вместе с пакетом "database/sql" нужно подключить драйвер конкретной СУБД.

Пакет "database/sql" определяет интерфейсы для работы с БД, а драйвер предоставляет реализацию этих интерфейсов.

Использование пакета "database/sql" позволяет максимально унифицировать код взаимодействия с БД, что позволяет перейти с одной СУБД на другую с минимальными правками кода, в теории ☺️

На практике это почти невозможно, поскольку SQL-диалекты разных СУБД отличаются (в первую очередь — параметры подготовленных запросов).

**Использование only драйвера БД**
В случае работы с БД в обход пакета "database/sql", формат команд определяется API конкретного драйвера БД.

Например, драйвер Postgres "github.com/lib/pq" использует "database/sql", в то время как "github.com/jackc/pgx" может работать как через "database/sql", так и напрямую.

Использование "database/sql" накладывает ряд ограничений, в основном на типы данных.
___
<h5>database/sql</h5>
Шикарное введение: http://go-database-sql.org/index.html

Пакет "database/sql" определяет ряд типов данных для работы с БД:
- `DB` — база данных (пул подключений)
- `Rows` — результат выполнения запроса
- `Result` — данные, полученные после выполнения запроса
- `Tx` — транзакция

Пакет "database/sql" использует драйвер конкретной СУБД для выполнения запросов.

Для работы с БД нужно импортировать пакет драйвера:
```go
import (
	"database/sql"
	_ "github.com/go-sql-driver/mysql"
)
```

Основной файл:
```go
package main  
  
import (  
    "context"  
    "database/sql"    
    "fmt"    
    _ "github.com/go-sql-driver/mysql"  
    "github.com/joho/godotenv"    
    "log"    
    "os"
)  
  
type UsersRepo interface {  
    GetUsers(context.Context) ([]user, error)  
    AddUsers(context.Context) (int, error)  
}  
  
type user struct {  
    Id         int  
    Name       string  
    CreateDate []uint8  
}  
  
func main() {  
    // Чтение переменных окружения из .env файла.  
    err := godotenv.Load()  
  
    // Объект БД — пул подключений к СУБД.  
    // БД — долгоживущий объект, следует создавать    
    // только один объект для каждой БД.    
    // Далее этот объект следует передавать    
    // как зависимость.    
    var db *sql.DB  
  
    // Подключение к БД.  
    // В зависимости от драйвера, sql.Open может    
    // не выполнять фактического подключения,    
    // а только проверить параметры соединения с БД.    
    pwd := os.Getenv("MYSQL_PASSWORD")  
    db, err = sql.Open(  
       "mysql",  
       "root:"+pwd+"@tcp(localhost:3306)/mysql",  
    )  
    if err != nil {  
       log.Fatal(err)  
    }  
    // Очистка ресурсов после завершения программы.  
    defer func() {  
       if err = db.Close(); err != nil {  
          log.Fatal(err)  
       }  
    }()  
  
    // Проверка соединения с БД, на случай, если  
    // sql.Open не делает этого самостоятельно.    
    err = db.Ping()  
    if err != nil {  
       log.Fatal(err)  
    }  
  
    // Получение списка пользователей.  
    users, err := getAllUsers(db)  
    if err != nil {  
       log.Fatal(err)  
    }  
    fmt.Println("got users:")  
    for _, u := range users {  
       fmt.Printf("%+v\n", u)  
    }  
  
    // Добавление пользователей.  
    users = []user{  
       {Name: "misha"},  
       {Name: "masha"},  
    }  
    err = addUsers(db, users)  
  
    // Получение списка пользователей.  
    users, err = getAllUsers(db)  
    if err != nil {  
       log.Fatal(err)  
    }  
    fmt.Println("got users:")  
    for _, u := range users {  
       fmt.Printf("%+v\n", u)  
    }  
}  
  
// getAllUsers возвращает список всех пользователей.
func getAllUsers(db *sql.DB) ([]user, error) {  
    // Выполнение запроса выборки данных.  
    // Query осуществляет следующее:    
    // - подготовка запроса;    
    // - выполнение запроса;    
    // - закрытие соединения.    
    rows, err := db.Query(  
       `SELECT id  
                , name                , create_date             FROM users             WHERE id > ?`,  
       -1,  
    )  
    if err != nil {  
       return nil, err  
    }  
    defer rows.Close()  
  
    var users []user  
    for rows.Next() {  
       var u user  
       err = rows.Scan(  
          &u.Id,  
          &u.Name,  
          &u.CreateDate,  
       )  
       if err != nil {  
          return nil, err  
       }  
       users = append(users, u)  
    }  
    err = rows.Err()  
    if err != nil {  
       return nil, err  
    }  
  
    return users, nil  
}  
  
// addUsers осуществляет добавление списка
// пользователей в БД в рамках одной транзакции.  
func addUsers(db *sql.DB, users []user) error {  
    // Начало транзакции.  
    tx, err := db.Begin()  
    if err != nil {  
       // Откат транзакции в случае ошибки.  
       tx.Rollback()  
       return err  
    }  
  
    // Подготовка запроса для последующего  
    // многократного выполнения    
    stmt, err := tx.Prepare(  
       `INSERT INTO users  
        (name)            
	    VALUES             
	    (?)`,  
    )  
    if err != nil {  
       return err  
    }  
    defer stmt.Close()  
  
    for _, user := range users {  
       res, err := stmt.Exec(user.Name)  
       if err != nil {  
          // Откат транзакции в случае ошибки.  
          tx.Rollback()  
          return err  
       }  
       id, _ := res.LastInsertId()  
       fmt.Println("Создана запись id =", id)  
    }  
  
    // Коммит транзакции.  
    err = tx.Commit()  
    if err != nil {  
       // Откат транзакции в случае ошибки.  
       tx.Rollback()  
       return err  
    }  
  
    return nil  
}
```

.env-файл:
```env
MYSQL_PASSWORD=mysql
```

`sql.Quyery()` используется для выборки данных и возвращает результат в виде `sql.Rows()`.
Далее полученные данные должны быть просканированы в переменные.
**Целью сканирования всегда должен быть указатель.**
Важно не забывать проверять ошибку `rows.Err()`.

Существует также функция `QueryRow()`, применяемая, когда требуется получить только одну строку.

`sql.Exec()` используется для изменения данных и возвращает `sql.Result`.

`sql.Result` позволяет посмотреть количество изменённых строк в результате выполнения запроса и идентификатор последней созданной записи.
___
<h5>Подготовленные запросы</h5>
Запросы с помощью `sql.Query()` и `sql.Exec()` совершают три похода в БД:
- подготовка запроса
- выполнение запроса
- завершение соединения

После подготовки запроса, он привязывается к одному соединению и получает идентификатор.

В случае, когда требуется многократное выполнение одинакового запроса (например, вставка большого числа записей) можно однократно подготовить запрос и далее отсылать в БД идентификатор запроса и параметры.

Таким образом можно избежать подготовки запроса и завершения соединения для каждой операции, т.е. сократить количество походов в БД почти в 3 раза.

Подготовка запроса для последующего многократного выполнения:
```go
stmt, err := db.Prepare(`
	INSERT INTO books
	(title, year)
	VALUES
	(?, ?)
`)
defer stmt.Close()

for _, book := range books {
	res, err := stmt.Exec(book.Title, book.Year)
	if err != nil { ... }
}
```
___
<h5>Транзакции</h5>
Транзакция позволяет объединить несколько операций в группу. Группа этих операций выполнится либо целиком, либо не выполнится вообще.

Транзакции позволяют объединить несколько операций в одну и выполнить её как одно целое — всё или ничего.

ACID:
- atomicity
- consistency
- isolation
- durability

**Atomicity**
Атомарность гарантирует, что каждая транзакция будет выполнена полностью или не будет выполнена совсем. Не допускаются промежуточные состояния.

**Consistency**
> [!NOTE] Wikipedia
> Транзакция, достигающая своего нормального завершения (_EOT — end of transaction_, завершение транзакции) и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных. Другими словами, каждая успешная транзакция по определению фиксирует только допустимые результаты

Это свойство вытекает из предыдущего. Благодаря тому, что транзакция не допускает промежуточных результатов, база остается консистентной. Есть такое определение транзакции: «Упорядоченное множество операций, **переводящих базу данных из одного согласованного состояния в другое**». То есть до выполнения операции и после база остается консистентной (в переводе на русский — согласованной).

**Isolation**
Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат.

Подробнее:

**Durability**
Если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя. Обесточилась система, произошел сбой в оборудовании? На выполненную транзакцию это не повлияет.

Подробнее про все 4 свойства:
 https://habr.com/ru/articles/555920/

Для работы с транзакциями следует использовать методы:
- `tx, err := db.Begin()` — начало транзакции
- `tx.Commit()` — подтверждение/фиксация/коммит транзакции
- `tx.Rollback()` — отказ транзакции

Использовать операторы SQL Begin и End не рекомендуется вообще.

Смешивать `sql.Begin()` с SQL-оператором `BEGIN` нельзя!
___
<h5>Работа с БД напрямую</h5>
Почему некоторые авторы некоторых драйверов решили не использовать "database/sql", а работать с БД напрямую?
Причина может быть в том, что "database/sql" представляет ограничения, которые автор драйвера хочет обойти.

"database/sql" стремится к универсализации работы с БД, однако повышение универсальности влечёт понижение гибкости. Например, "database/sql" не поддерживает некоторые типы данных.

Поэтому некоторые драйверы предлагают работу с БД напрямую, минуя интерфейс пакета "database/sql".

Примером такого драйвера является pgx (https://github.com/jackc/pgx/v5), поддерживающий значительно большее количество типов данных (массивы, JSON, NULL и т.д.)

pgx предоставляет API, похожий на "database/sql" (`Query()`, `QueryRow()`, `Exec()`).

На практике, следует всегда использовать производный пакет `pgxpool`, поддерживающий работу с пулом соединений с БД.

**Пример.**

.env
```.env
POSTGRES_USER=postgres  
POSTGRES_PASSWORD=postgres  
POSTGRES_HOST=localhost  
POSTGRES_PORT=5432
```

pgxpoool.go
```go
package main  
  
import (  
    "context"  
    "fmt"    
    "github.com/jackc/pgx/v5/pgxpool"    
    "github.com/joho/godotenv"    
    "log"    
    "os"    
    "time"
)  
  
type user struct {  
    Id         int  
    Name       string  
    Birthday   time.Time  
    CreateDate time.Time  
}  
  
func main() {  
    if err := godotenv.Load(); err != nil {  
       log.Fatal(err)  
    }  
  
    ctx := context.Background()  
    // Подключение к БД, функция возвращает  
    // объект БД.    
    postgresUser, postgresPassword, postgresHost, postgresPort :=  
       os.Getenv("POSTGRES_USER"),  
       os.Getenv("POSTGRES_PASSWORD"),  
       os.Getenv("POSTGRES_HOST"),  
       os.Getenv("POSTGRES_PORT")  
    postgresUrl := fmt.Sprintf(  
       "postgres://%s:%s@%s:%s/postgres",  
       postgresUser,  
       postgresPassword,  
       postgresHost,  
       postgresPort,  
    )  
  
    db, err := pgxpool.New(ctx, postgresUrl)  
    if err != nil {  
       log.Fatal(err)  
    }  
    defer db.Close()  
  
    err = db.Ping(ctx)  
    if err != nil {  
       log.Fatal(err)  
    }  
  
    // Получение списка пользователей.  
    users, err := getUsersFromDB(ctx, db)  
    if err != nil {  
       log.Fatal(err)  
    }  
    fmt.Printf("%+v\n", users)  
}  
  
func getUsersFromDB(ctx context.Context, db *pgxpool.Pool) ([]user, error) {  
    rows, err := db.Query(ctx,  
       `SELECT id  
               , name               , birthday               , create_date           FROM public.users           WHERE id > $1`,  
       -1,  
    )  
    if err != nil {  
       return nil, err  
    }  
    defer rows.Close()  
  
    var users []user  
    for rows.Next() {  
       var u user  
       err = rows.Scan(  
          &u.Id,  
          &u.Name,  
          &u.Birthday,  
          &u.CreateDate,  
       )  
       if err != nil {  
          return nil, err  
       }  
       users = append(users, u)  
    }  
    err = rows.Err()  
    if err != nil {  
       return nil, err  
    }  
  
    return users, nil  
}
```

<h6>Слово про откат транзакции</h6>
`defer` отката транзакции можно писать прямо после создания транзакции, так как закомиченная транзакция не будет откачена. Но если произошла ошибка, то мы не дойдём до коммита транзакции, и случится откат.

```go
func addUsers(ctx context.Context, db *pgxpool.Pool, users []user) error {
	tx, err := db.Begin(ctx)
	if err != nil {
		return err
	}
	defer tx.Rollback(ctx)
	
	...

	return tx.Commit(ctx)
}
```

<h6>Слово про подготовленный запрос</h6>
В `pgx` нет понятия подготовленного запроса, но есть понятие пакетного запроса. Это нечто похожее.

```go
// Пакетный запрос.
var batch = &pgx.Batch{}
// Добавление заданий в пакет.
for _, user := range users {
	batch.Queue(`INSERT INTO users(name) VALUES ($1)`, user.Name)
}
// Отправка пакета в БД (может выполняться для
// транзакции или соединения).
res := tx.SendBatch(ctx, batch)
// Обязательная операция закрытия соединения.
err = res.Close()
if err != nil {
	return err
}
// Подтверждение транзакции.
return tx.Commit(ctx)
```
___
<h5>Пакет для работы с БД</h5>
Существуют разные варианты организации кода, содержащего логику по работе с базой данных. Одним из вариантов является следующий:
1. Пакет "storage": содержит интерфейс для работы с БД.
2. Пакет "posgtgres" ("oracel", "mysql" и т.д.): содержит конкретную реализацию интерфейса "storage" для выбранной СУБД, внутри методы делятся по сущностям.
3. Пакет "memdb": содержит заглушку, реализующую интерфейс "storage" в памяти для тестирования.

storage
	postgres
		 postgres.go
	mysql
		 mysql.go
	 memdb
		 memdb.go
	storage.go

Такой подход позволяет сосредоточить весь код по работе с БД в одном пакете, что упрощает поиск ошибок и рефакторинг.

Альтернативным вариантом организации кода может являться вынесение кода для работы с БД в пакеты с бизнес-логикой, с разделением по сущностям. Например, пакет для работы с пользователями (бизнес-логика + БД), пакет для работы с подписками пользователей (бизнес-логика + БД) и т.д.
<h6>Шаблон репозиторий</h6>
Часто для организации кода, инкапсулирующего работу с БД, применяют шаблон "репозиторий":
https://threedots.tech/post/repository-pattern-in-go/

```go
// Использование шаблона "репозиторий".
type BooksRepo struct {
	GetBooks(context.Context) ([]book, error)
	AddBook(context.Context, book) (int, error)
}
```

Можно сказать, что шаблон репозиторий способствует удовлетворению принципу Interface Segregation Principle.
___
<h5>Тестирование пакета для работы с БД</h5>
Тестирование пакета, взаимодействующего с БД, является интеграционным по определению, и требует наличие базы данных.

Не рекомендуется выполнять тестирование рабочей БД. Вместо этого стоит создать тестовую базу данных с подготовленными данными, похожими на реальные. Но, на самом деле, надо смотреть по ситуации (тесты на чтение возможно стоит выполнить на рабочей БД, чтобы измерить скорость выполнения).

Тесты для БД должны быть идемпотентны (то есть многочисленный перезапуск теста должен давать один и тот же результат, например добавление записи и сравнение идентификатора созданной записи).

Тесты по возможности должны очищать созданные данные. Зачастую для подобных тестов каждый раз создаётся своя собственная БД, обычно в контейнере.